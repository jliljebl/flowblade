<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fluxity API documentation</title>
<meta name="description" content="GPL Licence text …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fluxity</code></h1>
</header>
<section id="section-intro">
<h3 id="gpl-licence-text">GPL Licence text</h3>
<p>Flowblade Movie Editor is a nonlinear video editor.
Copyright 2021 Janne Liljeblad.</p>
<p>This file is part of Flowblade Movie Editor <a href="http://code.google.com/p/flowblade">http://code.google.com/p/flowblade</a>.</p>
<p>Flowblade Movie Editor is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.</p>
<p>Flowblade Movie Editor is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with Flowblade Movie Editor. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<h1 id="fluxity-scripting">FLUXITY SCRIPTING</h1>
<p>Fluxity scripting is a <strong>Python scripting solution</strong> created to provide <strong>Flowblade Movie Editor</strong> with a <strong>Media Plugin API</strong>.</p>
<h2 id="required-interface">REQUIRED INTERFACE</h2>
<p>A Python script that satisfies the following interface will load and run without crashing, but will not necessarily create any output.</p>
<pre><code>def init_script(fctx):

def init_render(fctx):

def render_frame(frame, fctx, w, h):
</code></pre>
<h2 id="flowblade-media-plugin-api">FLOWBLADE MEDIA PLUGIN API</h2>
<p>That Flowblade Media Plugin API is provided by <em>fluxity.FluxityContext</em> object and its methods.</p>
<p>This object is created to communicate with the script before calling any of the methods of a Media Plugin script.</p>
<p>See API this document below for <em>fluxity.FluxityContext</em> object API details.</p>
<h2 id="flowblade-media-plugin-script-lifecycle">FLOWBLADE MEDIA PLUGIN SCRIPT LIFECYCLE</h2>
<p><strong>init_script(fctx):</strong> - This method is called when script is first loaded by Flowblade to create data structures with info on editors and script metadata. </p>
<p><strong>init_render(fctx):</strong> - This method is called before a render is started to get user input on editors and possibly to create some additional data strctures.</p>
<p><strong>render_frame(frame, fctx, w, h):</strong> - This method is called for each frame rendered to create output image.</p>
<h2 id="example-script">EXAMPLE SCRIPT</h2>
<p>Here have an example script called <em>'Floating Balls'</em> that is distributed as a Media Plugin with Flowblade.</p>
<h3 id="init_script">init_script()</h3>
<pre><code>import cairo
import numpy as np
import random
import math

def init_script(fctx):
    fctx.set_name(&quot;Floating Balls&quot;)
    fctx.set_author(&quot;Janne Liljeblad&quot;)

    fctx.add_editor(&quot;Hue&quot;, fctx.EDITOR_COLOR, (0.8, 0.50, 0.3, 1.0))
    fctx.add_editor(&quot;Speed&quot;, fctx.EDITOR_FLOAT_RANGE, (1.0, -5.0, 5.0))
    fctx.add_editor(&quot;Speed Variation %&quot;, fctx.EDITOR_INT_RANGE, (40, 0, 99))
    fctx.add_editor(&quot;Number of Balls&quot;, fctx.EDITOR_INT_RANGE, (50, 10, 500))
</code></pre>
<p>In <em>init_script()</em> we set some metadata like the name of the script diplayed to the user and author name, and we also define the editors that will be presented to the user.</p>
<h3 id="init_render">init_render()</h3>
<pre><code>def init_render(fctx):
    hue = fctx.get_editor_value(&quot;Hue&quot;)
    hr, hg, hb, alpha = hue
    fctx.set_data_obj(&quot;hue_tuple&quot;, hue)
    color_array = list(hue)
    ball_colors = []
    color_mult = 1.05

    for i in range(0, 10):
        array = np.array(color_array) * color_mult
        r, g, b, a = array
        ball_colors.append(cairo.SolidPattern(_clamp(r), _clamp(g), _clamp(b), 1.0))
        color_array = array
    fctx.set_data_obj(&quot;ball_colors&quot;, ball_colors)

    ball_data = []
    number_of_balls, mix, max = fctx.get_editor_value(&quot;Number of Balls&quot;)
    speed, mix, max = fctx.get_editor_value(&quot;Speed&quot;)
    speed_var_size_precentage, min, max = fctx.get_editor_value(&quot;Speed Variation %&quot;)
    for i in range(0, number_of_balls):
        path_pos = random.uniform(0.0, 1.0)
        y = random.randint(-330, 1080 + 330)
        speed_var = random.uniform(-1.0, 1.0)
        speed_var_size = speed * (speed_var_size_precentage  / 100.0)
        ball_speed = speed + (speed_var * speed_var_size  )
        # fctx.log_line(&quot;ball speed: &quot; + str(ball_speed) + &quot; &quot; + str(speed_var_size))
        color_index = random.randint(0, 9)
        ball_data.append((path_pos, y, ball_speed, color_index))
    fctx.set_data_obj(&quot;ball_data&quot;, ball_data)
</code></pre>
<p>In <em>init_render()</em> we read editor values set by the user and create the data structures for moving ball animations based on that data.</p>
<p>There should not be need to read editor values in other methods then <em>init_render()</em> since the editors are described in method <em>init_script()</em> and used in method <em>render_frame()</em> during render when user does not have access to edit the values.</p>
<h3 id="render_frame">render_frame()</h3>
<pre><code>def render_frame(frame, fctx, w, h):
    # Frame Render code here
    cr = fctx.get_frame_cr()

    bg_color = cairo.SolidPattern(*fctx.get_data_obj(&quot;hue_tuple&quot;))
    ball_colors = fctx.get_data_obj(&quot;ball_colors&quot;)
    ball_data = fctx.get_data_obj(&quot;ball_data&quot;)

    cr.set_source(bg_color)
    cr.rectangle(0, 0, w, h)
    cr.fill()

    size = 330.0
    xc = size / 2.0;
    yc = size / 2.0;

    number_of_balls, min, max = fctx.get_editor_value(&quot;Number of Balls&quot;)
    path_start_x = - size
    path_end_x =  w + size
    path_len = path_end_x - path_start_x
    SPEED_NORM_PER_FRAME = 15.0 / float(w) 
    for i in range(0, number_of_balls):
        path_pos, y, ball_speed, color_index = ball_data[i]
        #fctx.log_msg(str(i) + &quot; &quot; + str(x))
        xpos_norm = path_pos + (float(frame) * ball_speed * SPEED_NORM_PER_FRAME)
        while xpos_norm &gt; 1.0:
            xpos_norm = xpos_norm - 1.0
        x = path_start_x + path_len * xpos_norm
        cr.save()
        cr.translate(x, y)
        cr.arc(xc, yc, size / 4.0, 0.0, 2.0 * math.pi)
        cr.set_source(ball_colors[color_index])
        cr.fill()
        cr.restore()

# ----------------------- helper func
def _clamp(v):
    return max(min(v, 1.0), 0.0)
</code></pre>
<p>In <em>render_frame()</em> we first get access to <em>Cairo.Context</em> object that can be drawn onto to create output for current frame.</p>
<p>After that the data structures created in <em>init_render()</em> are accessed and image for frame is drawn.</p>
<p>There is a helper function <em>_clamp(v)</em> used to make sure that all color values are in range 0-1. Any number of helper functions and data structures can be created to achieve the desired output.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    ### GPL Licence text

    Flowblade Movie Editor is a nonlinear video editor.
    Copyright 2021 Janne Liljeblad.

    This file is part of Flowblade Movie Editor &lt;http://code.google.com/p/flowblade&gt;.

    Flowblade Movie Editor is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Flowblade Movie Editor is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Flowblade Movie Editor. If not, see &lt;http://www.gnu.org/licenses/&gt;.
    
    
    # FLUXITY SCRIPTING
    
    Fluxity scripting is a **Python scripting solution** created to provide **Flowblade Movie Editor** with a **Media Plugin API**.
    
    ## REQUIRED INTERFACE
    
    A Python script that satisfies the following interface will load and run without crashing, but will not necessarily create any output.
    
    ```
    def init_script(fctx):
    
    def init_render(fctx):
    
    def render_frame(frame, fctx, w, h):
    ```
    
    ## FLOWBLADE MEDIA PLUGIN API
    
    That Flowblade Media Plugin API is provided by *fluxity.FluxityContext* object and its methods.

    This object is created to communicate with the script before calling any of the methods of a Media Plugin script.
    
    See API this document below for *fluxity.FluxityContext* object API details.

    
    ## FLOWBLADE MEDIA PLUGIN SCRIPT LIFECYCLE
    
    **init_script(fctx):** - This method is called when script is first loaded by Flowblade to create data structures with info on editors and script metadata. 
    
    **init_render(fctx):** - This method is called before a render is started to get user input on editors and possibly to create some additional data strctures.
    
    **render_frame(frame, fctx, w, h):** - This method is called for each frame rendered to create output image.
    
    
    ## EXAMPLE SCRIPT
    
    Here have an example script called *&#39;Floating Balls&#39;* that is distributed as a Media Plugin with Flowblade.
    
    ### init_script()
    
    ```
    import cairo
    import numpy as np
    import random
    import math

    def init_script(fctx):
        fctx.set_name(&#34;Floating Balls&#34;)
        fctx.set_author(&#34;Janne Liljeblad&#34;)
        
        fctx.add_editor(&#34;Hue&#34;, fctx.EDITOR_COLOR, (0.8, 0.50, 0.3, 1.0))
        fctx.add_editor(&#34;Speed&#34;, fctx.EDITOR_FLOAT_RANGE, (1.0, -5.0, 5.0))
        fctx.add_editor(&#34;Speed Variation %&#34;, fctx.EDITOR_INT_RANGE, (40, 0, 99))
        fctx.add_editor(&#34;Number of Balls&#34;, fctx.EDITOR_INT_RANGE, (50, 10, 500))
    ```
    In *init_script()* we set some metadata like the name of the script diplayed to the user and author name, and we also define the editors that will be presented to the user.

    ### init_render()
    ```
    def init_render(fctx):
        hue = fctx.get_editor_value(&#34;Hue&#34;)
        hr, hg, hb, alpha = hue
        fctx.set_data_obj(&#34;hue_tuple&#34;, hue)
        color_array = list(hue)
        ball_colors = []
        color_mult = 1.05

        for i in range(0, 10):
            array = np.array(color_array) * color_mult
            r, g, b, a = array
            ball_colors.append(cairo.SolidPattern(_clamp(r), _clamp(g), _clamp(b), 1.0))
            color_array = array
        fctx.set_data_obj(&#34;ball_colors&#34;, ball_colors)

        ball_data = []
        number_of_balls, mix, max = fctx.get_editor_value(&#34;Number of Balls&#34;)
        speed, mix, max = fctx.get_editor_value(&#34;Speed&#34;)
        speed_var_size_precentage, min, max = fctx.get_editor_value(&#34;Speed Variation %&#34;)
        for i in range(0, number_of_balls):
            path_pos = random.uniform(0.0, 1.0)
            y = random.randint(-330, 1080 + 330)
            speed_var = random.uniform(-1.0, 1.0)
            speed_var_size = speed * (speed_var_size_precentage  / 100.0)
            ball_speed = speed + (speed_var * speed_var_size  )
            # fctx.log_line(&#34;ball speed: &#34; + str(ball_speed) + &#34; &#34; + str(speed_var_size))
            color_index = random.randint(0, 9)
            ball_data.append((path_pos, y, ball_speed, color_index))
        fctx.set_data_obj(&#34;ball_data&#34;, ball_data)
    ```
    In *init_render()* we read editor values set by the user and create the data structures for moving ball animations based on that data.

    There should not be need to read editor values in other methods then *init_render()* since the editors are described in method *init_script()* and used in method *render_frame()* during render when user does not have access to edit the values.

    ### render_frame()
    ```
    def render_frame(frame, fctx, w, h):
        # Frame Render code here
        cr = fctx.get_frame_cr()

        bg_color = cairo.SolidPattern(*fctx.get_data_obj(&#34;hue_tuple&#34;))
        ball_colors = fctx.get_data_obj(&#34;ball_colors&#34;)
        ball_data = fctx.get_data_obj(&#34;ball_data&#34;)

        cr.set_source(bg_color)
        cr.rectangle(0, 0, w, h)
        cr.fill()

        size = 330.0
        xc = size / 2.0;
        yc = size / 2.0;

        number_of_balls, min, max = fctx.get_editor_value(&#34;Number of Balls&#34;)
        path_start_x = - size
        path_end_x =  w + size
        path_len = path_end_x - path_start_x
        SPEED_NORM_PER_FRAME = 15.0 / float(w) 
        for i in range(0, number_of_balls):
            path_pos, y, ball_speed, color_index = ball_data[i]
            #fctx.log_msg(str(i) + &#34; &#34; + str(x))
            xpos_norm = path_pos + (float(frame) * ball_speed * SPEED_NORM_PER_FRAME)
            while xpos_norm &gt; 1.0:
                xpos_norm = xpos_norm - 1.0
            x = path_start_x + path_len * xpos_norm
            cr.save()
            cr.translate(x, y)
            cr.arc(xc, yc, size / 4.0, 0.0, 2.0 * math.pi)
            cr.set_source(ball_colors[color_index])
            cr.fill()
            cr.restore()

    # ----------------------- helper func
    def _clamp(v):
        return max(min(v, 1.0), 0.0)
    ```
    In *render_frame()* we first get access to *Cairo.Context* object that can be drawn onto to create output for current frame.
    
    After that the data structures created in *init_render()* are accessed and image for frame is drawn.
    
    There is a helper function *_clamp(v)* used to make sure that all color values are in range 0-1. Any number of helper functions and data structures can be created to achieve the desired output.
    
&#34;&#34;&#34;
import gi
gi.require_version(&#39;Pango&#39;, &#39;1.0&#39;)
gi.require_version(&#39;PangoCairo&#39;, &#39;1.0&#39;)
from gi.repository import Pango
from gi.repository import PangoCairo

import cairo
import json
import locale
import multiprocessing
import numpy as np
import os
import traceback

# MLR repo object
repo = None

# Default length in frames for script duration
DEFAULT_LENGTH = 200

METHOD_INIT_SCRIPT = 0
METHOD_INIT_RENDER = 1
METHOD_RENDER_FRAME = 2

# Pango font contants.
FACE_REGULAR = &#34;Regular&#34;
FACE_BOLD = &#34;Bold&#34;
FACE_ITALIC = &#34;Italic&#34;
FACE_BOLD_ITALIC = &#34;Bold Italic&#34;
DEFAULT_FONT_SIZE = 40

FLUXITY_ERROR_MSG = &#34;ERROR&#34;
FLUXITY_LOG_MSG = &#34;LOG&#34;

VERTICAL = 0
HORIZONTAL = 1

# Script displayed at Flowblade Script tool on init.
DEFAULT_SCRIPT = \
&#34;&#34;&#34;
import cairo

def init_script(fctx):
    # Script init here
    fctx.add_editor(&#34;float_editor&#34;, fctx.EDITOR_FLOAT, 1.0)
    fctx.set_name(&#34;Default Test Plugin&#34;)

def init_render(fctx):
    # Render init here
    fctx.set_data_obj(&#34;bg_color&#34;, cairo.SolidPattern(0.8, 0.2, 0.2, 1.0))
 
def render_frame(frame, fctx, w, h):
    # Frame Render code here
    cr = fctx.get_frame_cr()
    color = fctx.get_data_obj(&#34;bg_color&#34;)
    cr.set_source(color)
    cr.rectangle(0, 0, w, h)
    cr.fill()
&#34;&#34;&#34;


# ---------------------------------------------------------- script object
class FluxityScript:
    &#34;&#34;&#34;
    Compiles script to an executable object and calls methods *init_script()*, *init_render()*, *render_frame()* on it.
    
    Internal class, do not use objects of this class directly in scripts.
    &#34;&#34;&#34;
    
    def __init__(self, script_str):
        self.script = script_str
        self.code = None
        self.namespace = {}
    
    def compile_script(self):
        &#34;&#34;&#34;
        Compiles user script.
        &#34;&#34;&#34;
        try:
            self.code = compile(self.script, &#34;&lt;fluxityscript&gt;&#34;, &#34;exec&#34;)
        except Exception as e:
            _raise_compile_error(str(e))
        
        code_names = sorted(self.code.co_names)
        required_names = sorted([&#34;init_script&#34;,&#34;init_render&#34;,&#34;render_frame&#34;])
        contains_all = all(elem in code_names for elem in required_names)
        if contains_all == False:
            _raise_fluxity_error(&#34;Functions names &#34; + str(required_names) + &#34; all required to be in script, you have: &#34; + str(code_names))
  
        try:
            exec(self.code, self.namespace)
        except Exception as e:
            _raise_exec_error(str(e))
    
    def call_init_script(self, fctx):
        &#34;&#34;&#34;
        Calls method *init_script()* on script.
        &#34;&#34;&#34;
        try:
          self.namespace[&#39;init_script&#39;](fctx)
        except Exception as e:
          _raise_fluxity_error(&#34;error calling function &#39;init_script()&#39;:&#34; + str(e))

    def call_init_render(self, fctx):
        &#34;&#34;&#34;
        Calls method *init_render()* on script.
        &#34;&#34;&#34;
        try:
          self.namespace[&#39;init_render&#39;](fctx)
        except Exception as e:
          _raise_fluxity_error(&#34;error calling function &#39;init_render()&#39;:\n\n&#34; + str(e))
          
    def call_render_frame(self, frame, fctx, w, h):
        &#34;&#34;&#34;
        Calls method *render_frame()* on script.
        &#34;&#34;&#34;
        try:
          self.namespace[&#39;render_frame&#39;](frame, fctx, w, h)
        except Exception as e:
          _raise_fluxity_error(&#34;error calling function &#39;render_frame()&#39;:\n\n&#34; + str(e))


# ----------------------------------------------------------  Data structure correcponding with mlt.Profile
class FluxityProfile:
    &#34;&#34;&#34;    
    Properties of this class correspond MLT profile objects.
    
    Internal class, do not use objects of this class directly in scripts. 
    &#34;&#34;&#34;
    DESCRIPTION = &#34;description&#34;
    FRAME_RATE_NUM = &#34;frame_rate_num&#34;
    FRAME_RATE_DEN = &#34;frame_rate_den&#34;
    WIDTH = &#34;width&#34;
    HEIGHT = &#34;height&#34;
    PROGRESSIVE = &#34;progressive&#34;
    SAMPLE_ASPECT_NUM = &#34;sample_aspect_num&#34;
    SAMPLE_ASPECT_DEN = &#34;sample_aspect_den&#34;
    DISPLAY_ASPECT_NUM = &#34;display_aspect_num&#34;
    DISPLAY_ASPECT_DEN = &#34;display_aspect_den&#34;
    COLORSPACE = &#34;colorspace&#34;
        
    def __init__(self, profile_data):
        self.profile_data = profile_data
    
    def get_profile_property(self, prop):
        return self.profile_data[prop]

def _read_profile_prop_from_lines(lines, prop):
    for line in lines:
        sides = line.split(&#34;=&#34;)
        if sides[0] == prop:
            return sides[1]

    return None
        

# ---------------------------------------------------------- context object
class FluxityContext:

    EDITOR_STRING = 0
    &#34;&#34;&#34; Editor for strings that return string values as *quoted* strings. Generally *EDITOR_TEXT* should be used instead.&#34;&#34;&#34;
    EDITOR_TEXT = 1
    &#34;&#34;&#34; Editor for strings that return string values as unquoted strings.&#34;&#34;&#34;
    EDITOR_FLOAT = 2
    &#34;&#34;&#34; Editor for float values.&#34;&#34;&#34;
    EDITOR_INT = 3
    &#34;&#34;&#34; Editor for integer values.&#34;&#34;&#34;
    EDITOR_COLOR = 4
    &#34;&#34;&#34; Editor for colors. Value is a *(R,G,B,A)* tuple with values in range 0-1.&#34;&#34;&#34;
    EDITOR_FILE_PATH = 5
    &#34;&#34;&#34; Editor for selecting a file path. Value is Python pathname or *None*.&#34;&#34;&#34;
    EDITOR_OPTIONS = 6
    &#34;&#34;&#34; Editor for selecting between  2 - N  string options. Value is tuple *(selected_index,[option_str_1, option_str_2, ...])*.&#34;&#34;&#34;
    EDITOR_CHECK_BOX = 7
    &#34;&#34;&#34; Editor for boolean value. Value is either *True* or *False*&#34;&#34;&#34;
    EDITOR_FLOAT_RANGE = 8
    &#34;&#34;&#34; Editor for float values with a defined range of accepted values. Value is a 3-tuple *(default_val, min_val, max_val)*.&#34;&#34;&#34;
    EDITOR_INT_RANGE = 9
    &#34;&#34;&#34; Editor for integer valueswith a defined range of accepted values.&#34;&#34;&#34;
    EDITOR_PANGO_FONT = 10
    &#34;&#34;&#34; Editor for setting pango font properties.&#34;&#34;&#34;
    EDITOR_TEXT_AREA = 11
    &#34;&#34;&#34; Editor for creating multiline text.&#34;&#34;&#34;
    
    EDITOR_PANGO_FONT_DEFAULT_VALUES = (&#34;Times Roman&#34;, &#34;Regular&#34;, 80, Pango.Alignment.LEFT, (1.0, 1.0, 1.0, 1.0), \
                  True, (0.3, 0.3, 0.3, 1.0) , False, 2, False, (0.0, 0.0, 0.0), \
                  100, 3, 3, 0.0, None, VERTICAL)
    &#34;&#34;&#34; Pango Font Editor default values.&#34;&#34;&#34;

    PROFILE_DESCRIPTION = FluxityProfile.DESCRIPTION
    &#34;&#34;&#34;MLT Profile descriptiption string.&#34;&#34;&#34;
    PROFILE_FRAME_RATE_NUM = FluxityProfile.FRAME_RATE_NUM
    &#34;&#34;&#34;Frame rate numerator.&#34;&#34;&#34;
    PROFILE_FRAME_RATE_DEN = FluxityProfile.FRAME_RATE_DEN
    &#34;&#34;&#34;Frame rate denominator.&#34;&#34;&#34;
    PROFILE_WIDTH = FluxityProfile.WIDTH
    &#34;&#34;&#34;Output image width in pixels.&#34;&#34;&#34;
    PROFILE_HEIGHT = FluxityProfile.HEIGHT
    &#34;&#34;&#34;Output image height in pixels.&#34;&#34;&#34;
    PROFILE_PROGRESSIVE = FluxityProfile.PROGRESSIVE
    &#34;&#34;&#34;
    MLT Profile image is progressive if value is *True*, if value is *False* image is interlaced.
    &#34;&#34;&#34;
    PROFILE_SAMPLE_ASPECT_NUM = FluxityProfile.SAMPLE_ASPECT_NUM
    &#34;&#34;&#34;
    Pixel size fraction numerator.
    &#34;&#34;&#34;
    PROFILE_SAMPLE_ASPECT_DEN = FluxityProfile.SAMPLE_ASPECT_DEN
    &#34;&#34;&#34;
    Pixel size fraction denominator.
    &#34;&#34;&#34;
    PROFILE_DISPLAY_ASPECT_NUM = FluxityProfile.DISPLAY_ASPECT_NUM
    &#34;&#34;&#34;Output image size fraction numerator.&#34;&#34;&#34;
    PROFILE_DISPLAY_ASPECT_DEN = FluxityProfile.DISPLAY_ASPECT_DEN
    &#34;&#34;&#34;Output image size fraction denominator.&#34;&#34;&#34;
    PROFILE_COLORSPACE = FluxityProfile.COLORSPACE
    &#34;&#34;&#34;Profile colorspace, value is either 709, 601 or 2020.&#34;&#34;&#34;

    def __init__(self, script_file, output_folder):
        self.priv_context = FluxityContextPrivate(output_folder)
        self.script_file = script_file
        self.data = {}
        self.editors = {} # editors and script length
        self.editor_tooltips = {}
        self.length = DEFAULT_LENGTH
        self.name = &#34;Name Not Set&#34;
        self.version = 1
        self.author = &#34;Author Not Set&#34;
        self.error = None
        self.log_msg = &#34;&#34;

    def get_frame_cr(self):
        &#34;&#34;&#34;
        For every rendered frame method *render_frame()* is called and a new **cairo.ImageSurface** object is created.
        
        This method provides access to **cairo.Context** object that can be used to draw onto that image surface. This is the way that output is achieved with **Flowblade Media Plugins**. 
        
        After method *render_frame()* exits, contents of **cairo.ImageSurface** are saved to disk.
        
        Must be called in script method *render_frame()*.
        
        **Returns:** (**cairo.Context**) Context object that can be drawn onto.
        &#34;&#34;&#34;
        return self.priv_context.frame_cr

    def get_dimensions(self):
        &#34;&#34;&#34;
        Pixel size of output image.
        
        **Returns:** (tuple(width, height)) Image size.
        &#34;&#34;&#34;
        w = self.priv_context.profile.get_profile_property(FluxityProfile.WIDTH)
        h = self.priv_context.profile.get_profile_property(FluxityProfile.HEIGHT)
        return (w, h)

    def get_profile_property(self, p_property):
        &#34;&#34;&#34;
        **p_property(str):** propertyr identyfier, e.g. FluxityContext.PROFILE_PROGRESSIVE.
        
        Used to access properties of MLT profile set before running the script that defines e.g. output image size.
        
        **Returns:** (int || boolean || string) Value depends on which profile property is being accessed.
        &#34;&#34;&#34;
        return self.priv_context.profile.get_profile_property(p_property)
 
    def set_name(self, name):
        &#34;&#34;&#34;
        **name(str):** name of script displayed to user.
        
        Must be called in script method *init_script()*.
        &#34;&#34;&#34;
        self.name = name
        self.priv_context.error_on_wrong_method(&#34;set_name()&#34;, METHOD_INIT_SCRIPT)

    def set_version(self, version):
        &#34;&#34;&#34;
        **version(int):** version of script, use increasing integer numbering. Default value is *1*.
        
        Must be called in script method *init_script()*.
        &#34;&#34;&#34;
        self.version = version
        self.priv_context.error_on_wrong_method(&#34;set_version()&#34;, METHOD_INIT_SCRIPT)

    def set_author(self, author):
        &#34;&#34;&#34;
        **author(str):** name of script creator.
        
        Must be called in script method *init_script()*.
        &#34;&#34;&#34;
        self.author = author

    def set_frame_name(self, frame_name):
        &#34;&#34;&#34;        
        **frame_name(str):** name used before number part in rendered frame files.
        &#34;&#34;&#34;
        self.priv_context.frame_name = frame_name

    def set_data_obj(self, label, item):
        &#34;&#34;&#34;
        **label(str):** lable used to access data later using *get_data_obj(self, label)*.

        **item(obj):** data item being saved.
        
        Saves data to be used later during execution of script. Using **global** would obivously be possible to replace this, but this is made available as a more clean solution.
        &#34;&#34;&#34;
        self.data[label] = item

    def get_data_obj(self, label):
        &#34;&#34;&#34;
        **label(str):** lable of saved data item.
        
        Gives access to previously saved data.
        
        **Returns:** (obj) Saved data item.
        &#34;&#34;&#34;
        return self.data[label]

    def set_length(self, length):
        &#34;&#34;&#34;
        **length(int):** New length of script in frames.
        
        Sets length of script output in frames.
        
        Must *not* be called in  *render_frames()*.
        &#34;&#34;&#34;
        self.length = length

    def get_length(self):
        &#34;&#34;&#34;
        **Returns:** (int) Length of script in frames.
        &#34;&#34;&#34;
        return self.length

    def add_editor(self, name, type, default_value, tooltip=None):
        &#34;&#34;&#34;     
        **name(str):** Name for editor.
        
        **type(int):** Value either *EDITOR_STRING, EDITOR_VALUE, EDITOR_FLOAT, EDITOR_INT, EDITOR_COLOR, EDITOR_FILE_PATH, EDITOR_OPTIONS, EDITOR_CHECK_BOX, EDITOR_FLOAT_RANGE, EDITOR_INT_RANGE.*
        
        **default_value():** Data type depends on editor type:
        
          * EDITOR_STRING(str), 
          
          * EDITOR_VALUE(str), 
          
          * EDITOR_FLOAT(float), 
          
          * EDITOR_INT(int), 
          
          * EDITOR_COLOR(4-tuple with float values in range 0-1, (R,G,B,A)), 
          
          * EDITOR_FILE_PATH(str), 
          
          * EDITOR_OPTIONS (2-tuple (int, [str]), (selected_index,[option_str_1, option_str_2, ...]),
          
          * EDITOR_CHECK_BOX(bool), 
          
          * EDITOR_FLOAT_RANGE(3-tuple with float values, (default, min, max)), 
          
          * EDITOR_INT_RANGE(3-tuple with int values, (default, min, max))
          
          * EDITOR_PANGO_FONT (17-tuple (font_family, font_face, font_size, alignment, color_rgba,
                  fill_on, outline_color_rgba, outline_on, outline_width, shadow_on, shadow_color_rgb, 
                  shadow_opacity, shadow_xoff, shadow_yoff, shadow_blur, 
                  gradient_color_rgba, gradient_direction))
          
        **tooltip(str, optional):** Tooltip for editor if presented in GUI.
        
        Defines possible GUI editors used to affect script rendering. Edited value is accessed with method *get_editor_value(self, name, frame=0)*.
        
        Data describing editors can be accessed with *get_script_data(self)*. Edited values are made available for script with *set_editors_data(self, editors_data_json)*.
        
        Must be called in script method *init_script()*.
        &#34;&#34;&#34;
        self.editors[name] = (type, default_value)
        if tooltip != None:
            self.editor_tooltips[name] = tooltip
        self.priv_context.error_on_wrong_method(&#34;add_editor()&#34;, METHOD_INIT_SCRIPT)

    def get_editor_value(self, name, frame=0):
        &#34;&#34;&#34;     
        **name(str):** Name of editor.
        
        **frame(int):** Frame in range 0 - (script length - 1).
        
        Value of edited data at given frame. We currently have no animated values, but they will added with future API updates.
        
        **Returns:** (obj) Value at frame.
        
        Data type depends on editor type:
        
          * EDITOR_STRING(str), 
          
          * EDITOR_VALUE(str), 
          
          * EDITOR_FLOAT(float), 
          
          * EDITOR_INT(int), 
          
          * EDITOR_COLOR(4-tuple with float values in range 0-1, (R,G,B,A)), 
          
          * EDITOR_FILE_PATH(str), 
          
          * EDITOR_OPTIONS(selection index int),
          
          * EDITOR_CHECK_BOX(bool), 
          
          * EDITOR_FLOAT_RANGE(3-tuple with float values, (default, min, max)), 
          
          * EDITOR_INT_RANGE(3-tuple with int values, (default, min, max))

          * EDITOR_PANGO_FONT (17-tuple (font_family, font_face, font_size, alignment, color_rgba,
                  fill_on, outline_color_rgba, outline_on, outline_width, shadow_on, shadow_color_rgb, 
                  shadow_opacity, shadow_xoff, shadow_yoff, shadow_blur,
                  gradient_color_rgba, gradient_direction))
        &#34;&#34;&#34;
        try:
            type, value = self.editors[name]
            if type == FluxityContext.EDITOR_INT_RANGE or type == FluxityContext.EDITOR_FLOAT_RANGE:
                val, min, max = value
                return val 
            elif type == FluxityContext.EDITOR_OPTIONS:
                selected_index, options = value
                return selected_index
            return value
        except Exception as e:
            print(&#34;get_editor_value() &#34; + str(e) + traceback.format_exc(6,True))
            exception_msg = &#34;No editor for name &#39;&#34; + name + &#34;&#39; found.&#34;
            _raise_fluxity_error(exception_msg)

    def get_script_data(self):
        &#34;&#34;&#34;             
        Returns data of all editors and their default values, and script metadata like script author and version. 
        
        Output can be turned into Python object tree using *json.loads()* method.
        
        **Returns:** (str) string representation of JSON object.
        &#34;&#34;&#34;
        script_data = {}
        script_data[&#34;length&#34;] = self.length
        script_data[&#34;name&#34;] = self.name
        script_data[&#34;version&#34;] = self.version
        script_data[&#34;author&#34;] = self.author

        editors_list = []
        for name in self.editors:
            type, value = self.editors[name]
            json_obj = [name, type, value]
            editors_list.append(json_obj)

        script_data[&#34;editors_list&#34;] = editors_list # this is dict inside FluxityContext object, but is given out as list for convenience of Flowblade app integration.
        script_data[&#34;tooltips_list&#34;] = self.editor_tooltips
        
        return json.dumps(script_data)

    def get_script_dir(self):
        &#34;&#34;&#34;             
        Returns path to directory where the script being executed is located.  
        
        Sometimes script directory information is not available (e.g. when executing a non-saved script in Flowblade *Scrip Tool* application) and *None* is returned. It is recommeded that all Fluxity scripts handle getting *None* gracefully.
        
        This functionality is useful when script is being distributed with some associated media files.
        
        **Returns:** (str) script directory path or *None*.
        &#34;&#34;&#34;
        if self.script_file == None:
            return None
            
        dir_path = os.path.dirname(self.script_file) + &#34;/&#34;
        return dir_path
        
    def set_editors_data(self, editors_data_json):
        &#34;&#34;&#34;
        **editors_data_json(str):** string representation of JSON object.
                 
        Sets edited data to be used when rendering.
        
        Input string must describe JSON object that can be turned into usable editor data.
        
        *Example with EDITOR_FLOAT and EDITOR_COLOR:*
        
        ```
        [
            [&#34;Position X&#34;, 2, 1.0], 
            [&#34;BG Color&#34;, 4, [0.8, 0.2, 0.2, 1.0]]
        ]
        ```
        
        *General form:*
        
        ```
        [
            [&lt;name&gt;, &lt;type&gt;, &lt;value&gt;], 
            ...
        ]
        ```
        
        Using this method is not needed when creating **Flowblade Media Plugins**, application handles setting editors data.
        
        Should be called in script method *init_render()*.
        &#34;&#34;&#34;
        new_editors_list = json.loads(editors_data_json)
        for editor in new_editors_list:
            name, type, value = editor
            self.editors[name] = (type, value)

    def create_text_layout(self, font_data):
        &#34;&#34;&#34;
        **font_data(tuple)** this tuple can be aquired by calling *FluxityContext.get_editor_value()* on editors of type *FluxityContext.EDITOR_PANGO_FONT*.
                
        Creates obejcts used to draw text.

        **Returns:** (fluxity.PangoTextLayout) object for drawing text.
        &#34;&#34;&#34;
        return PangoTextLayout(font_data)
    
    def log_line(self, log_line):
        &#34;&#34;&#34;
        **log_line(str):** line of text.
                 
        Adds a line of text to log message displayed after completion or error.
        &#34;&#34;&#34;
        self.log_msg = self.log_msg + log_line + &#34;\n&#34;


class FluxityContextPrivate:
    &#34;&#34;&#34;
    This class exists to keep FluxityContext API clean for script developers.
    
    Internal class, do not use objects of this class directly in scripts. 
    &#34;&#34;&#34;
    def __init__(self, output_folder):

        self.profile = None
        
        self.output_folder = output_folder
        self.start_out_from_frame_one = False
        self.in_frame = -1

        self.frame = -1
        
        self.frame_surface = None
        self.frame_cr = None

        self.frame_name = &#34;frame&#34;
        self.first_rendered_frame_path = None # This is cleared by rendering routines.

        self.current_method = None
        self.method_name = {METHOD_INIT_SCRIPT:&#34;init_script()&#34;, METHOD_INIT_RENDER:&#34;init_render()&#34;, METHOD_RENDER_FRAME:&#34;render_frame()&#34;}
        
        self.repo = None
        
    def load_profile(self, mlt_profile_path):
        lines = []
        with open(mlt_profile_path, &#34;r&#34;) as f:
            for line in f:
                lines.append(line.strip())
        data = {}
        data[FluxityProfile.DESCRIPTION] = _read_profile_prop_from_lines(lines, FluxityProfile.DESCRIPTION)
        data[FluxityProfile.FRAME_RATE_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.FRAME_RATE_NUM)
        data[FluxityProfile.FRAME_RATE_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.FRAME_RATE_DEN)
        data[FluxityProfile.WIDTH] = int(_read_profile_prop_from_lines(lines, FluxityProfile.WIDTH))
        data[FluxityProfile.HEIGHT] = int(_read_profile_prop_from_lines(lines, FluxityProfile.HEIGHT))
        data[FluxityProfile.PROGRESSIVE] = _read_profile_prop_from_lines(lines, FluxityProfile.PROGRESSIVE)
        data[FluxityProfile.SAMPLE_ASPECT_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.SAMPLE_ASPECT_NUM)
        data[FluxityProfile.SAMPLE_ASPECT_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.SAMPLE_ASPECT_DEN)
        data[FluxityProfile.DISPLAY_ASPECT_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.DISPLAY_ASPECT_NUM)
        data[FluxityProfile.DISPLAY_ASPECT_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.DISPLAY_ASPECT_DEN)
        data[FluxityProfile.COLORSPACE] = _read_profile_prop_from_lines(lines, FluxityProfile.COLORSPACE)

        self.profile = FluxityProfile(data)

        return self.profile.profile_data
        
    def create_frame_surface(self, frame):
        self.frame = frame
        w = self.profile.profile_data[FluxityProfile.WIDTH]
        h = self.profile.profile_data[FluxityProfile.HEIGHT]
        self.frame_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, w, h)
        self.frame_cr = cairo.Context(self.frame_surface)

    def write_out_frame(self, is_preview_frame=False):
        if self.output_folder == None or os.path.isdir(self.output_folder) == False:
            exception_msg = &#34;Output folder &#34; + self.output_folder + &#34; does not exist.&#34;
            _raise_fluxity_error(exception_msg)
        
        out_frame_number = self.frame
        if self.start_out_from_frame_one == True:
            out_frame_number = self.frame - self.in_frame + 1 

        filepath = self.output_folder + &#34;/&#34; + self.frame_name + &#34;_&#34; + str(out_frame_number).rjust(5, &#34;0&#34;) + &#34;.png&#34;
        if is_preview_frame == True:
            filepath = self.output_folder + &#34;/preview.png&#34;
        self.frame_surface.write_to_png(filepath)

        if self.first_rendered_frame_path == None:
            self.first_rendered_frame_path = filepath

    def get_preview_frame_path(self):
        return self.output_folder + &#34;/preview.png&#34;
    
    def error_on_wrong_method(self, method_name, required_method):
        if required_method == self.current_method:
            return
        
        error_str = &#34;&#39;FluxityContext.&#34; + method_name + &#34;&#39; has to called in script method &#39;&#34; + self.method_name[required_method] + &#34;&#39;.&#34;
        _raise_contained_error(error_str)
    
class FluxityEmptyClass:
    &#34;&#34;&#34;
    Internal class, do not use objects of this class directly in scripts.
    &#34;&#34;&#34;
    pass

class PangoTextLayout:

    &#34;&#34;&#34;
    **font_data(tuple)** this tuple can be aquired by calling *FluxityContext.get_editor_value()* on editors of type *FluxityContext.EDITOR_PANGO_FONT*.
            
    Object for drawing text. Uses internally Pango.
    
    Instances of this object can be created using *FluxityContext.create_text_layout(font_data)*.
    &#34;&#34;&#34;
    def __init__(self, font_data):
        self.font_family, self.font_face, self.font_size, self.alignment, \
        self.color_rgba, self.fill_on, self.outline_color_rgba, self.outline_on, \
        self.outline_width, self.shadow_on, self.shadow_color_rgb, self.shadow_opacity, \
        self.shadow_xoff, self.shadow_yoff, self.shadow_blur, self.gradient_color_rgba, \
        self.gradient_direction = font_data
        self.font_desc = Pango.FontDescription(self.font_family + &#34; &#34; + self.font_face + &#34; &#34; + str(self.font_size))
        self.pango_layout = None

    def create_pango_layout(self, cr, text):
        &#34;&#34;&#34;
        **cr(cairo.Context)** frame cairo context aquired with FluxityContext.get_frame_cr().
        
        **text(str)** displayed text.
        
        Creates internally PangoCairo layout object. Calling this is required before calling *get_pixel_size()*.
        &#34;&#34;&#34;
        self.text = text
        self.pango_layout = PangoCairo.create_layout(cr)
        self.pango_layout.set_text(self.text, -1)
        self.pango_layout.set_font_description(self.font_desc)
        self.pango_layout.set_alignment(self.alignment)
        self.pixel_size = self.pango_layout.get_pixel_size()
        
    # called from vieweditor draw vieweditor-&gt; editorlayer-&gt;here
    def draw_layout(self, text, cr, x, y, rotation=0.0, xscale=1.0, yscale=1.0):
        &#34;&#34;&#34;
        **text(str)** displayed text.
        
        **cr(cairo.Context)** frame cairo context aquired with *FluxityContext.get_frame_cr()*.
        
        **x(float)** Text X position.

        **y(float)** Text Y position.

        **rotation(float)** Text rotation.

        **xscale(float)** Text X scaling.

        **yscale(float)** Text Y scaling.

        Draws text on provided *cairo.Context*.
        
        Calls internally *create_pango_layout()* so *get_pixel_size()* can be called after this.
        &#34;&#34;&#34;
        self.text = text
        cr.save() # Created each frame
        
        self.create_pango_layout(cr, text)
        layout = self.pango_layout # this just artifact of dev. history, create_pango_layout() was added later then draw_layout()
                                   # to be used in typewriter plugin.
        # Shadow
        if self.shadow_on:
            cr.save()

            # Get colors.
            r, g, b = self.shadow_color_rgb
            a = self.shadow_opacity / 100.0

            # Blurred shadow need its own ImageSurface
            if self.shadow_blur != 0.0:
                blurred_img = cairo.ImageSurface(cairo.FORMAT_ARGB32, view_editor.profile_w,  view_editor.profile_h)
                cr_blurred = cairo.Context(blurred_img)
                transform_cr = cr_blurred # Set draw transform_cr to context for newly created image.
            else:
                transform_cr = cr # Set draw transform_cr to out context.

            # Transform and set color.
            transform_cr.set_source_rgba(r, g, b, a)
            effective_shadow_xoff = self.shadow_xoff * xscale
            effective_shadow_yoff = self.shadow_yoff * yscale
            transform_cr.move_to(x + effective_shadow_xoff, y + effective_shadow_yoff)
            transform_cr.scale(xscale, yscale)
            transform_cr.rotate(rotation)

            # If no blur for shadow, just draw layout on out context.
            if self.shadow_blur == 0.0:
                PangoCairo.update_layout(cr, layout)
                PangoCairo.show_layout(cr, layout)
                cr.restore()
            else:
                # If we have blur - draw shadow, blur it and then draw on out context.
                PangoCairo.update_layout(cr_blurred, layout)
                PangoCairo.show_layout(cr_blurred, layout)

                img2 = Image.frombuffer(&#34;RGBA&#34;, (blurred_img.get_width(), blurred_img.get_height()), blurred_img.get_data(), &#34;raw&#34;, &#34;RGBA&#34;, 0, 1)
                effective_blur = xscale * self.shadow_blur # This is not going to be exact
                                                           # on non-100% scales but let&#39;s try to get approximation. 
                img2 = img2.filter(ImageFilter.GaussianBlur(radius=int(effective_blur)))
                imgd = img2.tobytes()
                a = array.array(&#39;B&#39;,imgd)

                stride = blurred_img.get_width() * 4
                draw_surface = cairo.ImageSurface.create_for_data (a, cairo.FORMAT_ARGB32,
                                                              blurred_img.get_width(), blurred_img.get_height(), stride)
                cr.restore()
                cr.set_source_surface(draw_surface, 0, 0)
                cr.paint()

        # Text
        if self.fill_on:
            if self.gradient_color_rgba == None:
                cr.set_source_rgba(*self.color_rgba)
            else:
                w, h = self.pixel_size
                w = float(w) * xscale
                h = float(h) * yscale
                if self.gradient_direction == HORIZONTAL:
                    grad = cairo.LinearGradient (x, 0, x + w, 0)
                else:
                    grad = cairo.LinearGradient (0, y, 0, y + h)
                
                r, g, b, a = self.color_rgba
                rg, gg, bg, ag =  self.gradient_color_rgba 
                    
                CLIP_COLOR_GRAD_1 = (0,  r, g, b, 1)
                CLIP_COLOR_GRAD_2 = (1,  rg, gg, bg, 1)
                grad.add_color_stop_rgba(*CLIP_COLOR_GRAD_1)
                grad.add_color_stop_rgba(*CLIP_COLOR_GRAD_2)
                cr.set_source(grad)

            cr.move_to(x, y)
            cr.scale(xscale, yscale)
            cr.rotate(rotation)
            
            PangoCairo.update_layout(cr, layout)
            PangoCairo.show_layout(cr, layout)
        
        # Outline
        if self.outline_on:
            if self.fill_on == False: # case when user only wants outline we need to transform here
                cr.move_to(x, y)
                cr.scale(xscale, yscale)
                cr.rotate(rotation)
            PangoCairo.layout_path(cr, layout)
            cr.set_source_rgba(*self.outline_color_rgba)
            cr.set_line_width(self.outline_width)
            cr.stroke()
        
        cr.restore()

    def get_pixel_size(self):
        &#34;&#34;&#34;             
        Returns size of layout.

        Before calling this PangoCairo layout object needs to creted *create_pango_layout()* or *draw_layout().*
        
        **Returns:** (width, height) pixel size of layout.
        &#34;&#34;&#34;
        return self.pixel_size 

    def get_pango_alignment(self):
        &#34;&#34;&#34;             
        Returns alignment for his layout.

        To interpret enums script must do import *from gi.repository import Pango*
        
        **Returns:** (int) alignment enum, either *Pango.Alignment.CENTER*, *Pango.Alignment.LEFT* or *Pango.Alignment.RIGHT*.
        &#34;&#34;&#34;
        return self.alignment
            
# ---------------------------------------------------------- Errors 
class FluxityError(Exception):
    &#34;&#34;&#34;
    Errors specific to using Fluxity API.
    
    Internal class, do not use objects of this class directly in scripts. 
    &#34;&#34;&#34;
    def __init__(self, msg):
        self.message = msg
        super().__init__(self.message)

def _raise_contained_error(exception_msg):
    raise FluxityError(exception_msg)
    
def _raise_fluxity_error(exception_msg):
    raise FluxityError(&#34;Fluxity Error: &#34; + exception_msg)
    
def _raise_compile_error(exception_msg):
    raise FluxityError(&#34;Error compiling Fluxity script:\n&#34; + exception_msg)

def _raise_exec_error(exception_msg):
    raise FluxityError(&#34;Error on doing exec() to create script code object:\n&#34; + exception_msg)

# ------------------------------------------------------ rendering
def render_preview_frame(script, script_file, frame, out_folder, profile_file_path, editors_data_json=None):
    &#34;&#34;&#34;
    **script(str)** Script to be rendered as a string.
    
    **script_file(str)** Absolut path to file containing script. If this is not provided methods some like *FluxityContext.get_script_dir()* will not function as intended.
    
    **frame(int)** Frame to be rendered in range 0 - *(script_length - 1)*.
    
    **out_folder(str)** Path to folder where rendered frame will be saved.
    
    **profile_file_path(str)** Path to a file containing a file describing MLT profile used to when rendering the script.
    
    **editors_data_json(str)** String representation of JSON object containing editors described in the script and their values. This is optional, not providing this will use default values given in script when rendering.
    
    Renders a single frame from provided script.
    
    **Returns:** (FluxityContext) Object created during rendering. This object has attributes *error* and *log_msg* providing error and logging information.
    &#34;&#34;&#34;

    try:
        # Init script and context.
        error_msg, results = _init_script_and_context(script, script_file, out_folder, profile_file_path)
        if error_msg != None:
            fake_fctx = FluxityEmptyClass()
            fake_fctx.error = error_msg
            fake_fctx.log_msg = &#34;&#34;
            return fake_fctx

        fscript, fctx = results

        # Execute script to render a preview frame.
        fctx.priv_context.current_method = METHOD_INIT_SCRIPT
        fscript.call_init_script(fctx)

        if editors_data_json != None:
            fctx.set_editors_data(editors_data_json)

        fctx.priv_context.current_method = METHOD_INIT_RENDER
        fscript.call_init_render(fctx)

        fctx.priv_context.current_method = METHOD_RENDER_FRAME
        fctx.priv_context.create_frame_surface(frame)
        w, h = fctx.get_dimensions()
        fscript.call_render_frame(frame, fctx, w, h)

        return fctx
    except Exception as e:
        fctx.error = str(e) + traceback.format_exc(6,True)
        print(fctx.error)
        trace = traceback.format_exc(6,True)
        return fctx

def render_frame_sequence(script, script_file, in_frame, out_frame, out_folder, profile_file_path, editors_data_json=None, start_out_from_frame_one=False):
    &#34;&#34;&#34;
    **script(str)** Script to be rendered as a string.
    
    **script_file(str)** Absolut path to file containing script. If this is not provided methods some like *FluxityContext.get_script_dir()* will not function as intended.
    
    **in_frame(int)** First frame of rendered range.

    **out_frame(int)** Last frame of rendered range, exclusive.
    
    **out_folder(str)** Path to folder where rendered frame will be saved.
    
    **profile_file_path(str)** Path to a file containing a file describing MLT profile used to when rendering the script.
    
    **editors_data_json(str)** String representation of JSON object containing editors described in the script and their values. This is optional, not providing this will use default values given in script when rendering.
    
    **start_out_from_frame_one(boolean)** Setting this *True* will cause numbering of rendered frame sequence to start from *1*, otherwise it will start from *in_frame*. 
    
    Renders a range of frames from provided script.
    
    **Returns:** (dict) Dictionary object created during rendering with the following information:
    
    * for each process it has *key -&gt; value* pair *process number(str) -&gt; path to first frame redered by process(str)*.
    * if errors occurred during rendering it has *key -&gt; value* pair *fluxity.FLUXITY_ERROR_MSG -&gt; error message(str)*.
    * if script created log messages it has *key -&gt; value* pair *fluxity.FLUXITY_LOG_MSG -&gt; log message(str)*.
    &#34;&#34;&#34;
    
    threads = 6 # add some heuristics here.
    if out_frame - in_frame &lt; threads * 2:
        threads = 1

    manager = multiprocessing.Manager()
    proc_fctx_dict = manager.dict()
    jobs = []
    for i in range(threads):
        if i == 0:
            update_callback = None
        else:
            update_callback = None
        
        render_data = ( script, script_file, in_frame, out_frame, out_folder, \
                        profile_file_path, update_callback, \
                        editors_data_json, start_out_from_frame_one)
        
        proc_info = (i, threads, proc_fctx_dict)
        p = multiprocessing.Process(target=_render_process_launch, args=(render_data, proc_info))
        jobs.append(p)
        p.start()

    for proc in jobs:
        proc.join()

    return proc_fctx_dict
        
def _render_process_launch(render_data, proc_info):
    script, script_file, in_frame, out_frame, out_folder, \
    profile_file_path, frame_write_callback, \
    editors_data_json, start_out_from_frame_one = render_data
    
    procnum, threads_count, proc_fctx_dict = proc_info
    
    try:
        # Init script and context.
        error_msg, results = _init_script_and_context(script, script_file, out_folder, profile_file_path)
        if error_msg != None:
            fake_fctx = FluxityEmptyClass()
            fake_fctx.error = error_msg
            proc_fctx_dict[procnum] = fake_fctx
            return 

        fscript, fctx = results

                    
        # Execute script to write frame sequence.
        fctx.priv_context.current_method = METHOD_INIT_SCRIPT
        fscript.call_init_script(fctx)

        if editors_data_json != None:
            fctx.set_editors_data(editors_data_json)
            
        fctx.priv_context.current_method = METHOD_INIT_RENDER
        fscript.call_init_render(fctx)

        fctx.priv_context.first_rendered_frame_path = None # Should be clear but let&#39;s make sure. 
        fctx.priv_context.current_method = METHOD_RENDER_FRAME
        fctx.priv_context.start_out_from_frame_one = start_out_from_frame_one
        fctx.priv_context.in_frame = in_frame
        
        for frame in range(in_frame + procnum, out_frame, threads_count):
            fctx.priv_context.create_frame_surface(frame)
            w, h = fctx.get_dimensions()
            fscript.call_render_frame(frame, fctx, w, h)
            fctx.priv_context.write_out_frame()
            if frame_write_callback != None:
                frame_write_callback(frame) # for GUI app opdates.

        proc_fctx_dict[str(procnum)] = str(fctx.priv_context.first_rendered_frame_path)
        if len(fctx.log_msg) &gt; 0:
            proc_fctx_dict[str(FLUXITY_LOG_MSG)] = str(fctx.log_msg)
        
    except Exception as e:
        fctx.error = str(e) + traceback.format_exc(6,True)
        proc_fctx_dict[str(FLUXITY_ERROR_MSG)] = str(fctx.error)

        
def _init_script_and_context(script, script_file, out_folder, profile_file_path):
    try:

        fscript = FluxityScript(script)
        fscript.compile_script()
        
        fctx = FluxityContext(script_file, out_folder)
        fctx.priv_context.load_profile(profile_file_path)
        
        return (None, (fscript, fctx))
    except Exception as e:
        msg = str(e)
        return (msg, None)


    
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fluxity.render_frame_sequence"><code class="name flex">
<span>def <span class="ident">render_frame_sequence</span></span>(<span>script, script_file, in_frame, out_frame, out_folder, profile_file_path, editors_data_json=None, start_out_from_frame_one=False)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>script(str)</strong> Script to be rendered as a string.</p>
<p><strong>script_file(str)</strong> Absolut path to file containing script. If this is not provided methods some like <em>FluxityContext.get_script_dir()</em> will not function as intended.</p>
<p><strong>in_frame(int)</strong> First frame of rendered range.</p>
<p><strong>out_frame(int)</strong> Last frame of rendered range, exclusive.</p>
<p><strong>out_folder(str)</strong> Path to folder where rendered frame will be saved.</p>
<p><strong>profile_file_path(str)</strong> Path to a file containing a file describing MLT profile used to when rendering the script.</p>
<p><strong>editors_data_json(str)</strong> String representation of JSON object containing editors described in the script and their values. This is optional, not providing this will use default values given in script when rendering.</p>
<p><strong>start_out_from_frame_one(boolean)</strong> Setting this <em>True</em> will cause numbering of rendered frame sequence to start from <em>1</em>, otherwise it will start from <em>in_frame</em>. </p>
<p>Renders a range of frames from provided script.</p>
<p><strong>Returns:</strong> (dict) Dictionary object created during rendering with the following information:</p>
<ul>
<li>for each process it has <em>key -&gt; value</em> pair <em>process number(str) -&gt; path to first frame redered by process(str)</em>.</li>
<li>if errors occurred during rendering it has <em>key -&gt; value</em> pair <em>fluxity.FLUXITY_ERROR_MSG -&gt; error message(str)</em>.</li>
<li>if script created log messages it has <em>key -&gt; value</em> pair <em>fluxity.FLUXITY_LOG_MSG -&gt; log message(str)</em>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_frame_sequence(script, script_file, in_frame, out_frame, out_folder, profile_file_path, editors_data_json=None, start_out_from_frame_one=False):
    &#34;&#34;&#34;
    **script(str)** Script to be rendered as a string.
    
    **script_file(str)** Absolut path to file containing script. If this is not provided methods some like *FluxityContext.get_script_dir()* will not function as intended.
    
    **in_frame(int)** First frame of rendered range.

    **out_frame(int)** Last frame of rendered range, exclusive.
    
    **out_folder(str)** Path to folder where rendered frame will be saved.
    
    **profile_file_path(str)** Path to a file containing a file describing MLT profile used to when rendering the script.
    
    **editors_data_json(str)** String representation of JSON object containing editors described in the script and their values. This is optional, not providing this will use default values given in script when rendering.
    
    **start_out_from_frame_one(boolean)** Setting this *True* will cause numbering of rendered frame sequence to start from *1*, otherwise it will start from *in_frame*. 
    
    Renders a range of frames from provided script.
    
    **Returns:** (dict) Dictionary object created during rendering with the following information:
    
    * for each process it has *key -&gt; value* pair *process number(str) -&gt; path to first frame redered by process(str)*.
    * if errors occurred during rendering it has *key -&gt; value* pair *fluxity.FLUXITY_ERROR_MSG -&gt; error message(str)*.
    * if script created log messages it has *key -&gt; value* pair *fluxity.FLUXITY_LOG_MSG -&gt; log message(str)*.
    &#34;&#34;&#34;
    
    threads = 6 # add some heuristics here.
    if out_frame - in_frame &lt; threads * 2:
        threads = 1

    manager = multiprocessing.Manager()
    proc_fctx_dict = manager.dict()
    jobs = []
    for i in range(threads):
        if i == 0:
            update_callback = None
        else:
            update_callback = None
        
        render_data = ( script, script_file, in_frame, out_frame, out_folder, \
                        profile_file_path, update_callback, \
                        editors_data_json, start_out_from_frame_one)
        
        proc_info = (i, threads, proc_fctx_dict)
        p = multiprocessing.Process(target=_render_process_launch, args=(render_data, proc_info))
        jobs.append(p)
        p.start()

    for proc in jobs:
        proc.join()

    return proc_fctx_dict</code></pre>
</details>
</dd>
<dt id="fluxity.render_preview_frame"><code class="name flex">
<span>def <span class="ident">render_preview_frame</span></span>(<span>script, script_file, frame, out_folder, profile_file_path, editors_data_json=None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>script(str)</strong> Script to be rendered as a string.</p>
<p><strong>script_file(str)</strong> Absolut path to file containing script. If this is not provided methods some like <em>FluxityContext.get_script_dir()</em> will not function as intended.</p>
<p><strong>frame(int)</strong> Frame to be rendered in range 0 - <em>(script_length - 1)</em>.</p>
<p><strong>out_folder(str)</strong> Path to folder where rendered frame will be saved.</p>
<p><strong>profile_file_path(str)</strong> Path to a file containing a file describing MLT profile used to when rendering the script.</p>
<p><strong>editors_data_json(str)</strong> String representation of JSON object containing editors described in the script and their values. This is optional, not providing this will use default values given in script when rendering.</p>
<p>Renders a single frame from provided script.</p>
<p><strong>Returns:</strong> (FluxityContext) Object created during rendering. This object has attributes <em>error</em> and <em>log_msg</em> providing error and logging information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_preview_frame(script, script_file, frame, out_folder, profile_file_path, editors_data_json=None):
    &#34;&#34;&#34;
    **script(str)** Script to be rendered as a string.
    
    **script_file(str)** Absolut path to file containing script. If this is not provided methods some like *FluxityContext.get_script_dir()* will not function as intended.
    
    **frame(int)** Frame to be rendered in range 0 - *(script_length - 1)*.
    
    **out_folder(str)** Path to folder where rendered frame will be saved.
    
    **profile_file_path(str)** Path to a file containing a file describing MLT profile used to when rendering the script.
    
    **editors_data_json(str)** String representation of JSON object containing editors described in the script and their values. This is optional, not providing this will use default values given in script when rendering.
    
    Renders a single frame from provided script.
    
    **Returns:** (FluxityContext) Object created during rendering. This object has attributes *error* and *log_msg* providing error and logging information.
    &#34;&#34;&#34;

    try:
        # Init script and context.
        error_msg, results = _init_script_and_context(script, script_file, out_folder, profile_file_path)
        if error_msg != None:
            fake_fctx = FluxityEmptyClass()
            fake_fctx.error = error_msg
            fake_fctx.log_msg = &#34;&#34;
            return fake_fctx

        fscript, fctx = results

        # Execute script to render a preview frame.
        fctx.priv_context.current_method = METHOD_INIT_SCRIPT
        fscript.call_init_script(fctx)

        if editors_data_json != None:
            fctx.set_editors_data(editors_data_json)

        fctx.priv_context.current_method = METHOD_INIT_RENDER
        fscript.call_init_render(fctx)

        fctx.priv_context.current_method = METHOD_RENDER_FRAME
        fctx.priv_context.create_frame_surface(frame)
        w, h = fctx.get_dimensions()
        fscript.call_render_frame(frame, fctx, w, h)

        return fctx
    except Exception as e:
        fctx.error = str(e) + traceback.format_exc(6,True)
        print(fctx.error)
        trace = traceback.format_exc(6,True)
        return fctx</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fluxity.FluxityContext"><code class="flex name class">
<span>class <span class="ident">FluxityContext</span></span>
<span>(</span><span>script_file, output_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FluxityContext:

    EDITOR_STRING = 0
    &#34;&#34;&#34; Editor for strings that return string values as *quoted* strings. Generally *EDITOR_TEXT* should be used instead.&#34;&#34;&#34;
    EDITOR_TEXT = 1
    &#34;&#34;&#34; Editor for strings that return string values as unquoted strings.&#34;&#34;&#34;
    EDITOR_FLOAT = 2
    &#34;&#34;&#34; Editor for float values.&#34;&#34;&#34;
    EDITOR_INT = 3
    &#34;&#34;&#34; Editor for integer values.&#34;&#34;&#34;
    EDITOR_COLOR = 4
    &#34;&#34;&#34; Editor for colors. Value is a *(R,G,B,A)* tuple with values in range 0-1.&#34;&#34;&#34;
    EDITOR_FILE_PATH = 5
    &#34;&#34;&#34; Editor for selecting a file path. Value is Python pathname or *None*.&#34;&#34;&#34;
    EDITOR_OPTIONS = 6
    &#34;&#34;&#34; Editor for selecting between  2 - N  string options. Value is tuple *(selected_index,[option_str_1, option_str_2, ...])*.&#34;&#34;&#34;
    EDITOR_CHECK_BOX = 7
    &#34;&#34;&#34; Editor for boolean value. Value is either *True* or *False*&#34;&#34;&#34;
    EDITOR_FLOAT_RANGE = 8
    &#34;&#34;&#34; Editor for float values with a defined range of accepted values. Value is a 3-tuple *(default_val, min_val, max_val)*.&#34;&#34;&#34;
    EDITOR_INT_RANGE = 9
    &#34;&#34;&#34; Editor for integer valueswith a defined range of accepted values.&#34;&#34;&#34;
    EDITOR_PANGO_FONT = 10
    &#34;&#34;&#34; Editor for setting pango font properties.&#34;&#34;&#34;
    EDITOR_TEXT_AREA = 11
    &#34;&#34;&#34; Editor for creating multiline text.&#34;&#34;&#34;
    
    EDITOR_PANGO_FONT_DEFAULT_VALUES = (&#34;Times Roman&#34;, &#34;Regular&#34;, 80, Pango.Alignment.LEFT, (1.0, 1.0, 1.0, 1.0), \
                  True, (0.3, 0.3, 0.3, 1.0) , False, 2, False, (0.0, 0.0, 0.0), \
                  100, 3, 3, 0.0, None, VERTICAL)
    &#34;&#34;&#34; Pango Font Editor default values.&#34;&#34;&#34;

    PROFILE_DESCRIPTION = FluxityProfile.DESCRIPTION
    &#34;&#34;&#34;MLT Profile descriptiption string.&#34;&#34;&#34;
    PROFILE_FRAME_RATE_NUM = FluxityProfile.FRAME_RATE_NUM
    &#34;&#34;&#34;Frame rate numerator.&#34;&#34;&#34;
    PROFILE_FRAME_RATE_DEN = FluxityProfile.FRAME_RATE_DEN
    &#34;&#34;&#34;Frame rate denominator.&#34;&#34;&#34;
    PROFILE_WIDTH = FluxityProfile.WIDTH
    &#34;&#34;&#34;Output image width in pixels.&#34;&#34;&#34;
    PROFILE_HEIGHT = FluxityProfile.HEIGHT
    &#34;&#34;&#34;Output image height in pixels.&#34;&#34;&#34;
    PROFILE_PROGRESSIVE = FluxityProfile.PROGRESSIVE
    &#34;&#34;&#34;
    MLT Profile image is progressive if value is *True*, if value is *False* image is interlaced.
    &#34;&#34;&#34;
    PROFILE_SAMPLE_ASPECT_NUM = FluxityProfile.SAMPLE_ASPECT_NUM
    &#34;&#34;&#34;
    Pixel size fraction numerator.
    &#34;&#34;&#34;
    PROFILE_SAMPLE_ASPECT_DEN = FluxityProfile.SAMPLE_ASPECT_DEN
    &#34;&#34;&#34;
    Pixel size fraction denominator.
    &#34;&#34;&#34;
    PROFILE_DISPLAY_ASPECT_NUM = FluxityProfile.DISPLAY_ASPECT_NUM
    &#34;&#34;&#34;Output image size fraction numerator.&#34;&#34;&#34;
    PROFILE_DISPLAY_ASPECT_DEN = FluxityProfile.DISPLAY_ASPECT_DEN
    &#34;&#34;&#34;Output image size fraction denominator.&#34;&#34;&#34;
    PROFILE_COLORSPACE = FluxityProfile.COLORSPACE
    &#34;&#34;&#34;Profile colorspace, value is either 709, 601 or 2020.&#34;&#34;&#34;

    def __init__(self, script_file, output_folder):
        self.priv_context = FluxityContextPrivate(output_folder)
        self.script_file = script_file
        self.data = {}
        self.editors = {} # editors and script length
        self.editor_tooltips = {}
        self.length = DEFAULT_LENGTH
        self.name = &#34;Name Not Set&#34;
        self.version = 1
        self.author = &#34;Author Not Set&#34;
        self.error = None
        self.log_msg = &#34;&#34;

    def get_frame_cr(self):
        &#34;&#34;&#34;
        For every rendered frame method *render_frame()* is called and a new **cairo.ImageSurface** object is created.
        
        This method provides access to **cairo.Context** object that can be used to draw onto that image surface. This is the way that output is achieved with **Flowblade Media Plugins**. 
        
        After method *render_frame()* exits, contents of **cairo.ImageSurface** are saved to disk.
        
        Must be called in script method *render_frame()*.
        
        **Returns:** (**cairo.Context**) Context object that can be drawn onto.
        &#34;&#34;&#34;
        return self.priv_context.frame_cr

    def get_dimensions(self):
        &#34;&#34;&#34;
        Pixel size of output image.
        
        **Returns:** (tuple(width, height)) Image size.
        &#34;&#34;&#34;
        w = self.priv_context.profile.get_profile_property(FluxityProfile.WIDTH)
        h = self.priv_context.profile.get_profile_property(FluxityProfile.HEIGHT)
        return (w, h)

    def get_profile_property(self, p_property):
        &#34;&#34;&#34;
        **p_property(str):** propertyr identyfier, e.g. FluxityContext.PROFILE_PROGRESSIVE.
        
        Used to access properties of MLT profile set before running the script that defines e.g. output image size.
        
        **Returns:** (int || boolean || string) Value depends on which profile property is being accessed.
        &#34;&#34;&#34;
        return self.priv_context.profile.get_profile_property(p_property)
 
    def set_name(self, name):
        &#34;&#34;&#34;
        **name(str):** name of script displayed to user.
        
        Must be called in script method *init_script()*.
        &#34;&#34;&#34;
        self.name = name
        self.priv_context.error_on_wrong_method(&#34;set_name()&#34;, METHOD_INIT_SCRIPT)

    def set_version(self, version):
        &#34;&#34;&#34;
        **version(int):** version of script, use increasing integer numbering. Default value is *1*.
        
        Must be called in script method *init_script()*.
        &#34;&#34;&#34;
        self.version = version
        self.priv_context.error_on_wrong_method(&#34;set_version()&#34;, METHOD_INIT_SCRIPT)

    def set_author(self, author):
        &#34;&#34;&#34;
        **author(str):** name of script creator.
        
        Must be called in script method *init_script()*.
        &#34;&#34;&#34;
        self.author = author

    def set_frame_name(self, frame_name):
        &#34;&#34;&#34;        
        **frame_name(str):** name used before number part in rendered frame files.
        &#34;&#34;&#34;
        self.priv_context.frame_name = frame_name

    def set_data_obj(self, label, item):
        &#34;&#34;&#34;
        **label(str):** lable used to access data later using *get_data_obj(self, label)*.

        **item(obj):** data item being saved.
        
        Saves data to be used later during execution of script. Using **global** would obivously be possible to replace this, but this is made available as a more clean solution.
        &#34;&#34;&#34;
        self.data[label] = item

    def get_data_obj(self, label):
        &#34;&#34;&#34;
        **label(str):** lable of saved data item.
        
        Gives access to previously saved data.
        
        **Returns:** (obj) Saved data item.
        &#34;&#34;&#34;
        return self.data[label]

    def set_length(self, length):
        &#34;&#34;&#34;
        **length(int):** New length of script in frames.
        
        Sets length of script output in frames.
        
        Must *not* be called in  *render_frames()*.
        &#34;&#34;&#34;
        self.length = length

    def get_length(self):
        &#34;&#34;&#34;
        **Returns:** (int) Length of script in frames.
        &#34;&#34;&#34;
        return self.length

    def add_editor(self, name, type, default_value, tooltip=None):
        &#34;&#34;&#34;     
        **name(str):** Name for editor.
        
        **type(int):** Value either *EDITOR_STRING, EDITOR_VALUE, EDITOR_FLOAT, EDITOR_INT, EDITOR_COLOR, EDITOR_FILE_PATH, EDITOR_OPTIONS, EDITOR_CHECK_BOX, EDITOR_FLOAT_RANGE, EDITOR_INT_RANGE.*
        
        **default_value():** Data type depends on editor type:
        
          * EDITOR_STRING(str), 
          
          * EDITOR_VALUE(str), 
          
          * EDITOR_FLOAT(float), 
          
          * EDITOR_INT(int), 
          
          * EDITOR_COLOR(4-tuple with float values in range 0-1, (R,G,B,A)), 
          
          * EDITOR_FILE_PATH(str), 
          
          * EDITOR_OPTIONS (2-tuple (int, [str]), (selected_index,[option_str_1, option_str_2, ...]),
          
          * EDITOR_CHECK_BOX(bool), 
          
          * EDITOR_FLOAT_RANGE(3-tuple with float values, (default, min, max)), 
          
          * EDITOR_INT_RANGE(3-tuple with int values, (default, min, max))
          
          * EDITOR_PANGO_FONT (17-tuple (font_family, font_face, font_size, alignment, color_rgba,
                  fill_on, outline_color_rgba, outline_on, outline_width, shadow_on, shadow_color_rgb, 
                  shadow_opacity, shadow_xoff, shadow_yoff, shadow_blur, 
                  gradient_color_rgba, gradient_direction))
          
        **tooltip(str, optional):** Tooltip for editor if presented in GUI.
        
        Defines possible GUI editors used to affect script rendering. Edited value is accessed with method *get_editor_value(self, name, frame=0)*.
        
        Data describing editors can be accessed with *get_script_data(self)*. Edited values are made available for script with *set_editors_data(self, editors_data_json)*.
        
        Must be called in script method *init_script()*.
        &#34;&#34;&#34;
        self.editors[name] = (type, default_value)
        if tooltip != None:
            self.editor_tooltips[name] = tooltip
        self.priv_context.error_on_wrong_method(&#34;add_editor()&#34;, METHOD_INIT_SCRIPT)

    def get_editor_value(self, name, frame=0):
        &#34;&#34;&#34;     
        **name(str):** Name of editor.
        
        **frame(int):** Frame in range 0 - (script length - 1).
        
        Value of edited data at given frame. We currently have no animated values, but they will added with future API updates.
        
        **Returns:** (obj) Value at frame.
        
        Data type depends on editor type:
        
          * EDITOR_STRING(str), 
          
          * EDITOR_VALUE(str), 
          
          * EDITOR_FLOAT(float), 
          
          * EDITOR_INT(int), 
          
          * EDITOR_COLOR(4-tuple with float values in range 0-1, (R,G,B,A)), 
          
          * EDITOR_FILE_PATH(str), 
          
          * EDITOR_OPTIONS(selection index int),
          
          * EDITOR_CHECK_BOX(bool), 
          
          * EDITOR_FLOAT_RANGE(3-tuple with float values, (default, min, max)), 
          
          * EDITOR_INT_RANGE(3-tuple with int values, (default, min, max))

          * EDITOR_PANGO_FONT (17-tuple (font_family, font_face, font_size, alignment, color_rgba,
                  fill_on, outline_color_rgba, outline_on, outline_width, shadow_on, shadow_color_rgb, 
                  shadow_opacity, shadow_xoff, shadow_yoff, shadow_blur,
                  gradient_color_rgba, gradient_direction))
        &#34;&#34;&#34;
        try:
            type, value = self.editors[name]
            if type == FluxityContext.EDITOR_INT_RANGE or type == FluxityContext.EDITOR_FLOAT_RANGE:
                val, min, max = value
                return val 
            elif type == FluxityContext.EDITOR_OPTIONS:
                selected_index, options = value
                return selected_index
            return value
        except Exception as e:
            print(&#34;get_editor_value() &#34; + str(e) + traceback.format_exc(6,True))
            exception_msg = &#34;No editor for name &#39;&#34; + name + &#34;&#39; found.&#34;
            _raise_fluxity_error(exception_msg)

    def get_script_data(self):
        &#34;&#34;&#34;             
        Returns data of all editors and their default values, and script metadata like script author and version. 
        
        Output can be turned into Python object tree using *json.loads()* method.
        
        **Returns:** (str) string representation of JSON object.
        &#34;&#34;&#34;
        script_data = {}
        script_data[&#34;length&#34;] = self.length
        script_data[&#34;name&#34;] = self.name
        script_data[&#34;version&#34;] = self.version
        script_data[&#34;author&#34;] = self.author

        editors_list = []
        for name in self.editors:
            type, value = self.editors[name]
            json_obj = [name, type, value]
            editors_list.append(json_obj)

        script_data[&#34;editors_list&#34;] = editors_list # this is dict inside FluxityContext object, but is given out as list for convenience of Flowblade app integration.
        script_data[&#34;tooltips_list&#34;] = self.editor_tooltips
        
        return json.dumps(script_data)

    def get_script_dir(self):
        &#34;&#34;&#34;             
        Returns path to directory where the script being executed is located.  
        
        Sometimes script directory information is not available (e.g. when executing a non-saved script in Flowblade *Scrip Tool* application) and *None* is returned. It is recommeded that all Fluxity scripts handle getting *None* gracefully.
        
        This functionality is useful when script is being distributed with some associated media files.
        
        **Returns:** (str) script directory path or *None*.
        &#34;&#34;&#34;
        if self.script_file == None:
            return None
            
        dir_path = os.path.dirname(self.script_file) + &#34;/&#34;
        return dir_path
        
    def set_editors_data(self, editors_data_json):
        &#34;&#34;&#34;
        **editors_data_json(str):** string representation of JSON object.
                 
        Sets edited data to be used when rendering.
        
        Input string must describe JSON object that can be turned into usable editor data.
        
        *Example with EDITOR_FLOAT and EDITOR_COLOR:*
        
        ```
        [
            [&#34;Position X&#34;, 2, 1.0], 
            [&#34;BG Color&#34;, 4, [0.8, 0.2, 0.2, 1.0]]
        ]
        ```
        
        *General form:*
        
        ```
        [
            [&lt;name&gt;, &lt;type&gt;, &lt;value&gt;], 
            ...
        ]
        ```
        
        Using this method is not needed when creating **Flowblade Media Plugins**, application handles setting editors data.
        
        Should be called in script method *init_render()*.
        &#34;&#34;&#34;
        new_editors_list = json.loads(editors_data_json)
        for editor in new_editors_list:
            name, type, value = editor
            self.editors[name] = (type, value)

    def create_text_layout(self, font_data):
        &#34;&#34;&#34;
        **font_data(tuple)** this tuple can be aquired by calling *FluxityContext.get_editor_value()* on editors of type *FluxityContext.EDITOR_PANGO_FONT*.
                
        Creates obejcts used to draw text.

        **Returns:** (fluxity.PangoTextLayout) object for drawing text.
        &#34;&#34;&#34;
        return PangoTextLayout(font_data)
    
    def log_line(self, log_line):
        &#34;&#34;&#34;
        **log_line(str):** line of text.
                 
        Adds a line of text to log message displayed after completion or error.
        &#34;&#34;&#34;
        self.log_msg = self.log_msg + log_line + &#34;\n&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="fluxity.FluxityContext.EDITOR_CHECK_BOX"><code class="name">var <span class="ident">EDITOR_CHECK_BOX</span></code></dt>
<dd>
<div class="desc"><p>Editor for boolean value. Value is either <em>True</em> or <em>False</em></p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_COLOR"><code class="name">var <span class="ident">EDITOR_COLOR</span></code></dt>
<dd>
<div class="desc"><p>Editor for colors. Value is a <em>(R,G,B,A)</em> tuple with values in range 0-1.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_FILE_PATH"><code class="name">var <span class="ident">EDITOR_FILE_PATH</span></code></dt>
<dd>
<div class="desc"><p>Editor for selecting a file path. Value is Python pathname or <em>None</em>.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_FLOAT"><code class="name">var <span class="ident">EDITOR_FLOAT</span></code></dt>
<dd>
<div class="desc"><p>Editor for float values.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_FLOAT_RANGE"><code class="name">var <span class="ident">EDITOR_FLOAT_RANGE</span></code></dt>
<dd>
<div class="desc"><p>Editor for float values with a defined range of accepted values. Value is a 3-tuple <em>(default_val, min_val, max_val)</em>.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_INT"><code class="name">var <span class="ident">EDITOR_INT</span></code></dt>
<dd>
<div class="desc"><p>Editor for integer values.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_INT_RANGE"><code class="name">var <span class="ident">EDITOR_INT_RANGE</span></code></dt>
<dd>
<div class="desc"><p>Editor for integer valueswith a defined range of accepted values.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_OPTIONS"><code class="name">var <span class="ident">EDITOR_OPTIONS</span></code></dt>
<dd>
<div class="desc"><p>Editor for selecting between
2 - N
string options. Value is tuple <em>(selected_index,[option_str_1, option_str_2, &hellip;])</em>.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_PANGO_FONT"><code class="name">var <span class="ident">EDITOR_PANGO_FONT</span></code></dt>
<dd>
<div class="desc"><p>Editor for setting pango font properties.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_PANGO_FONT_DEFAULT_VALUES"><code class="name">var <span class="ident">EDITOR_PANGO_FONT_DEFAULT_VALUES</span></code></dt>
<dd>
<div class="desc"><p>Pango Font Editor default values.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_STRING"><code class="name">var <span class="ident">EDITOR_STRING</span></code></dt>
<dd>
<div class="desc"><p>Editor for strings that return string values as <em>quoted</em> strings. Generally <em>EDITOR_TEXT</em> should be used instead.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_TEXT"><code class="name">var <span class="ident">EDITOR_TEXT</span></code></dt>
<dd>
<div class="desc"><p>Editor for strings that return string values as unquoted strings.</p></div>
</dd>
<dt id="fluxity.FluxityContext.EDITOR_TEXT_AREA"><code class="name">var <span class="ident">EDITOR_TEXT_AREA</span></code></dt>
<dd>
<div class="desc"><p>Editor for creating multiline text.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_COLORSPACE"><code class="name">var <span class="ident">PROFILE_COLORSPACE</span></code></dt>
<dd>
<div class="desc"><p>Profile colorspace, value is either 709, 601 or 2020.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_DESCRIPTION"><code class="name">var <span class="ident">PROFILE_DESCRIPTION</span></code></dt>
<dd>
<div class="desc"><p>MLT Profile descriptiption string.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_DISPLAY_ASPECT_DEN"><code class="name">var <span class="ident">PROFILE_DISPLAY_ASPECT_DEN</span></code></dt>
<dd>
<div class="desc"><p>Output image size fraction denominator.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_DISPLAY_ASPECT_NUM"><code class="name">var <span class="ident">PROFILE_DISPLAY_ASPECT_NUM</span></code></dt>
<dd>
<div class="desc"><p>Output image size fraction numerator.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_FRAME_RATE_DEN"><code class="name">var <span class="ident">PROFILE_FRAME_RATE_DEN</span></code></dt>
<dd>
<div class="desc"><p>Frame rate denominator.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_FRAME_RATE_NUM"><code class="name">var <span class="ident">PROFILE_FRAME_RATE_NUM</span></code></dt>
<dd>
<div class="desc"><p>Frame rate numerator.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_HEIGHT"><code class="name">var <span class="ident">PROFILE_HEIGHT</span></code></dt>
<dd>
<div class="desc"><p>Output image height in pixels.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_PROGRESSIVE"><code class="name">var <span class="ident">PROFILE_PROGRESSIVE</span></code></dt>
<dd>
<div class="desc"><p>MLT Profile image is progressive if value is <em>True</em>, if value is <em>False</em> image is interlaced.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_SAMPLE_ASPECT_DEN"><code class="name">var <span class="ident">PROFILE_SAMPLE_ASPECT_DEN</span></code></dt>
<dd>
<div class="desc"><p>Pixel size fraction denominator.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_SAMPLE_ASPECT_NUM"><code class="name">var <span class="ident">PROFILE_SAMPLE_ASPECT_NUM</span></code></dt>
<dd>
<div class="desc"><p>Pixel size fraction numerator.</p></div>
</dd>
<dt id="fluxity.FluxityContext.PROFILE_WIDTH"><code class="name">var <span class="ident">PROFILE_WIDTH</span></code></dt>
<dd>
<div class="desc"><p>Output image width in pixels.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fluxity.FluxityContext.add_editor"><code class="name flex">
<span>def <span class="ident">add_editor</span></span>(<span>self, name, type, default_value, tooltip=None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>name(str):</strong> Name for editor.</p>
<p><strong>type(int):</strong> Value either <em>EDITOR_STRING, EDITOR_VALUE, EDITOR_FLOAT, EDITOR_INT, EDITOR_COLOR, EDITOR_FILE_PATH, EDITOR_OPTIONS, EDITOR_CHECK_BOX, EDITOR_FLOAT_RANGE, EDITOR_INT_RANGE.</em></p>
<p><strong>default_value():</strong> Data type depends on editor type:</p>
<ul>
<li>
<p>EDITOR_STRING(str), </p>
</li>
<li>
<p>EDITOR_VALUE(str), </p>
</li>
<li>
<p>EDITOR_FLOAT(float), </p>
</li>
<li>
<p>EDITOR_INT(int), </p>
</li>
<li>
<p>EDITOR_COLOR(4-tuple with float values in range 0-1, (R,G,B,A)), </p>
</li>
<li>
<p>EDITOR_FILE_PATH(str), </p>
</li>
<li>
<p>EDITOR_OPTIONS (2-tuple (int, [str]), (selected_index,[option_str_1, option_str_2, &hellip;]),</p>
</li>
<li>
<p>EDITOR_CHECK_BOX(bool), </p>
</li>
<li>
<p>EDITOR_FLOAT_RANGE(3-tuple with float values, (default, min, max)), </p>
</li>
<li>
<p>EDITOR_INT_RANGE(3-tuple with int values, (default, min, max))</p>
</li>
<li>
<p>EDITOR_PANGO_FONT (17-tuple (font_family, font_face, font_size, alignment, color_rgba,
fill_on, outline_color_rgba, outline_on, outline_width, shadow_on, shadow_color_rgb,
shadow_opacity, shadow_xoff, shadow_yoff, shadow_blur,
gradient_color_rgba, gradient_direction))</p>
</li>
</ul>
<p><strong>tooltip(str, optional):</strong> Tooltip for editor if presented in GUI.</p>
<p>Defines possible GUI editors used to affect script rendering. Edited value is accessed with method <em>get_editor_value(self, name, frame=0)</em>.</p>
<p>Data describing editors can be accessed with <em>get_script_data(self)</em>. Edited values are made available for script with <em>set_editors_data(self, editors_data_json)</em>.</p>
<p>Must be called in script method <em>init_script()</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_editor(self, name, type, default_value, tooltip=None):
    &#34;&#34;&#34;     
    **name(str):** Name for editor.
    
    **type(int):** Value either *EDITOR_STRING, EDITOR_VALUE, EDITOR_FLOAT, EDITOR_INT, EDITOR_COLOR, EDITOR_FILE_PATH, EDITOR_OPTIONS, EDITOR_CHECK_BOX, EDITOR_FLOAT_RANGE, EDITOR_INT_RANGE.*
    
    **default_value():** Data type depends on editor type:
    
      * EDITOR_STRING(str), 
      
      * EDITOR_VALUE(str), 
      
      * EDITOR_FLOAT(float), 
      
      * EDITOR_INT(int), 
      
      * EDITOR_COLOR(4-tuple with float values in range 0-1, (R,G,B,A)), 
      
      * EDITOR_FILE_PATH(str), 
      
      * EDITOR_OPTIONS (2-tuple (int, [str]), (selected_index,[option_str_1, option_str_2, ...]),
      
      * EDITOR_CHECK_BOX(bool), 
      
      * EDITOR_FLOAT_RANGE(3-tuple with float values, (default, min, max)), 
      
      * EDITOR_INT_RANGE(3-tuple with int values, (default, min, max))
      
      * EDITOR_PANGO_FONT (17-tuple (font_family, font_face, font_size, alignment, color_rgba,
              fill_on, outline_color_rgba, outline_on, outline_width, shadow_on, shadow_color_rgb, 
              shadow_opacity, shadow_xoff, shadow_yoff, shadow_blur, 
              gradient_color_rgba, gradient_direction))
      
    **tooltip(str, optional):** Tooltip for editor if presented in GUI.
    
    Defines possible GUI editors used to affect script rendering. Edited value is accessed with method *get_editor_value(self, name, frame=0)*.
    
    Data describing editors can be accessed with *get_script_data(self)*. Edited values are made available for script with *set_editors_data(self, editors_data_json)*.
    
    Must be called in script method *init_script()*.
    &#34;&#34;&#34;
    self.editors[name] = (type, default_value)
    if tooltip != None:
        self.editor_tooltips[name] = tooltip
    self.priv_context.error_on_wrong_method(&#34;add_editor()&#34;, METHOD_INIT_SCRIPT)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.create_text_layout"><code class="name flex">
<span>def <span class="ident">create_text_layout</span></span>(<span>self, font_data)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>font_data(tuple)</strong> this tuple can be aquired by calling <em>FluxityContext.get_editor_value()</em> on editors of type <em>FluxityContext.EDITOR_PANGO_FONT</em>.</p>
<p>Creates obejcts used to draw text.</p>
<p><strong>Returns:</strong> (fluxity.PangoTextLayout) object for drawing text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_text_layout(self, font_data):
    &#34;&#34;&#34;
    **font_data(tuple)** this tuple can be aquired by calling *FluxityContext.get_editor_value()* on editors of type *FluxityContext.EDITOR_PANGO_FONT*.
            
    Creates obejcts used to draw text.

    **Returns:** (fluxity.PangoTextLayout) object for drawing text.
    &#34;&#34;&#34;
    return PangoTextLayout(font_data)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.get_data_obj"><code class="name flex">
<span>def <span class="ident">get_data_obj</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>label(str):</strong> lable of saved data item.</p>
<p>Gives access to previously saved data.</p>
<p><strong>Returns:</strong> (obj) Saved data item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_obj(self, label):
    &#34;&#34;&#34;
    **label(str):** lable of saved data item.
    
    Gives access to previously saved data.
    
    **Returns:** (obj) Saved data item.
    &#34;&#34;&#34;
    return self.data[label]</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.get_dimensions"><code class="name flex">
<span>def <span class="ident">get_dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pixel size of output image.</p>
<p><strong>Returns:</strong> (tuple(width, height)) Image size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dimensions(self):
    &#34;&#34;&#34;
    Pixel size of output image.
    
    **Returns:** (tuple(width, height)) Image size.
    &#34;&#34;&#34;
    w = self.priv_context.profile.get_profile_property(FluxityProfile.WIDTH)
    h = self.priv_context.profile.get_profile_property(FluxityProfile.HEIGHT)
    return (w, h)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.get_editor_value"><code class="name flex">
<span>def <span class="ident">get_editor_value</span></span>(<span>self, name, frame=0)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>name(str):</strong> Name of editor.</p>
<p><strong>frame(int):</strong> Frame in range 0 - (script length - 1).</p>
<p>Value of edited data at given frame. We currently have no animated values, but they will added with future API updates.</p>
<p><strong>Returns:</strong> (obj) Value at frame.</p>
<p>Data type depends on editor type:</p>
<ul>
<li>
<p>EDITOR_STRING(str), </p>
</li>
<li>
<p>EDITOR_VALUE(str), </p>
</li>
<li>
<p>EDITOR_FLOAT(float), </p>
</li>
<li>
<p>EDITOR_INT(int), </p>
</li>
<li>
<p>EDITOR_COLOR(4-tuple with float values in range 0-1, (R,G,B,A)), </p>
</li>
<li>
<p>EDITOR_FILE_PATH(str), </p>
</li>
<li>
<p>EDITOR_OPTIONS(selection index int),</p>
</li>
<li>
<p>EDITOR_CHECK_BOX(bool), </p>
</li>
<li>
<p>EDITOR_FLOAT_RANGE(3-tuple with float values, (default, min, max)), </p>
</li>
<li>
<p>EDITOR_INT_RANGE(3-tuple with int values, (default, min, max))</p>
</li>
<li>
<p>EDITOR_PANGO_FONT (17-tuple (font_family, font_face, font_size, alignment, color_rgba,
fill_on, outline_color_rgba, outline_on, outline_width, shadow_on, shadow_color_rgb,
shadow_opacity, shadow_xoff, shadow_yoff, shadow_blur,
gradient_color_rgba, gradient_direction))</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_editor_value(self, name, frame=0):
    &#34;&#34;&#34;     
    **name(str):** Name of editor.
    
    **frame(int):** Frame in range 0 - (script length - 1).
    
    Value of edited data at given frame. We currently have no animated values, but they will added with future API updates.
    
    **Returns:** (obj) Value at frame.
    
    Data type depends on editor type:
    
      * EDITOR_STRING(str), 
      
      * EDITOR_VALUE(str), 
      
      * EDITOR_FLOAT(float), 
      
      * EDITOR_INT(int), 
      
      * EDITOR_COLOR(4-tuple with float values in range 0-1, (R,G,B,A)), 
      
      * EDITOR_FILE_PATH(str), 
      
      * EDITOR_OPTIONS(selection index int),
      
      * EDITOR_CHECK_BOX(bool), 
      
      * EDITOR_FLOAT_RANGE(3-tuple with float values, (default, min, max)), 
      
      * EDITOR_INT_RANGE(3-tuple with int values, (default, min, max))

      * EDITOR_PANGO_FONT (17-tuple (font_family, font_face, font_size, alignment, color_rgba,
              fill_on, outline_color_rgba, outline_on, outline_width, shadow_on, shadow_color_rgb, 
              shadow_opacity, shadow_xoff, shadow_yoff, shadow_blur,
              gradient_color_rgba, gradient_direction))
    &#34;&#34;&#34;
    try:
        type, value = self.editors[name]
        if type == FluxityContext.EDITOR_INT_RANGE or type == FluxityContext.EDITOR_FLOAT_RANGE:
            val, min, max = value
            return val 
        elif type == FluxityContext.EDITOR_OPTIONS:
            selected_index, options = value
            return selected_index
        return value
    except Exception as e:
        print(&#34;get_editor_value() &#34; + str(e) + traceback.format_exc(6,True))
        exception_msg = &#34;No editor for name &#39;&#34; + name + &#34;&#39; found.&#34;
        _raise_fluxity_error(exception_msg)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.get_frame_cr"><code class="name flex">
<span>def <span class="ident">get_frame_cr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>For every rendered frame method <em>render_frame()</em> is called and a new <strong>cairo.ImageSurface</strong> object is created.</p>
<p>This method provides access to <strong>cairo.Context</strong> object that can be used to draw onto that image surface. This is the way that output is achieved with <strong>Flowblade Media Plugins</strong>. </p>
<p>After method <em>render_frame()</em> exits, contents of <strong>cairo.ImageSurface</strong> are saved to disk.</p>
<p>Must be called in script method <em>render_frame()</em>.</p>
<p><strong>Returns:</strong> (<strong>cairo.Context</strong>) Context object that can be drawn onto.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame_cr(self):
    &#34;&#34;&#34;
    For every rendered frame method *render_frame()* is called and a new **cairo.ImageSurface** object is created.
    
    This method provides access to **cairo.Context** object that can be used to draw onto that image surface. This is the way that output is achieved with **Flowblade Media Plugins**. 
    
    After method *render_frame()* exits, contents of **cairo.ImageSurface** are saved to disk.
    
    Must be called in script method *render_frame()*.
    
    **Returns:** (**cairo.Context**) Context object that can be drawn onto.
    &#34;&#34;&#34;
    return self.priv_context.frame_cr</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.get_length"><code class="name flex">
<span>def <span class="ident">get_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Returns:</strong> (int) Length of script in frames.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_length(self):
    &#34;&#34;&#34;
    **Returns:** (int) Length of script in frames.
    &#34;&#34;&#34;
    return self.length</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.get_profile_property"><code class="name flex">
<span>def <span class="ident">get_profile_property</span></span>(<span>self, p_property)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>p_property(str):</strong> propertyr identyfier, e.g. FluxityContext.PROFILE_PROGRESSIVE.</p>
<p>Used to access properties of MLT profile set before running the script that defines e.g. output image size.</p>
<p><strong>Returns:</strong> (int || boolean || string) Value depends on which profile property is being accessed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_profile_property(self, p_property):
    &#34;&#34;&#34;
    **p_property(str):** propertyr identyfier, e.g. FluxityContext.PROFILE_PROGRESSIVE.
    
    Used to access properties of MLT profile set before running the script that defines e.g. output image size.
    
    **Returns:** (int || boolean || string) Value depends on which profile property is being accessed.
    &#34;&#34;&#34;
    return self.priv_context.profile.get_profile_property(p_property)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.get_script_data"><code class="name flex">
<span>def <span class="ident">get_script_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns data of all editors and their default values, and script metadata like script author and version. </p>
<p>Output can be turned into Python object tree using <em>json.loads()</em> method.</p>
<p><strong>Returns:</strong> (str) string representation of JSON object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_script_data(self):
    &#34;&#34;&#34;             
    Returns data of all editors and their default values, and script metadata like script author and version. 
    
    Output can be turned into Python object tree using *json.loads()* method.
    
    **Returns:** (str) string representation of JSON object.
    &#34;&#34;&#34;
    script_data = {}
    script_data[&#34;length&#34;] = self.length
    script_data[&#34;name&#34;] = self.name
    script_data[&#34;version&#34;] = self.version
    script_data[&#34;author&#34;] = self.author

    editors_list = []
    for name in self.editors:
        type, value = self.editors[name]
        json_obj = [name, type, value]
        editors_list.append(json_obj)

    script_data[&#34;editors_list&#34;] = editors_list # this is dict inside FluxityContext object, but is given out as list for convenience of Flowblade app integration.
    script_data[&#34;tooltips_list&#34;] = self.editor_tooltips
    
    return json.dumps(script_data)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.get_script_dir"><code class="name flex">
<span>def <span class="ident">get_script_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns path to directory where the script being executed is located.
</p>
<p>Sometimes script directory information is not available (e.g. when executing a non-saved script in Flowblade <em>Scrip Tool</em> application) and <em>None</em> is returned. It is recommeded that all Fluxity scripts handle getting <em>None</em> gracefully.</p>
<p>This functionality is useful when script is being distributed with some associated media files.</p>
<p><strong>Returns:</strong> (str) script directory path or <em>None</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_script_dir(self):
    &#34;&#34;&#34;             
    Returns path to directory where the script being executed is located.  
    
    Sometimes script directory information is not available (e.g. when executing a non-saved script in Flowblade *Scrip Tool* application) and *None* is returned. It is recommeded that all Fluxity scripts handle getting *None* gracefully.
    
    This functionality is useful when script is being distributed with some associated media files.
    
    **Returns:** (str) script directory path or *None*.
    &#34;&#34;&#34;
    if self.script_file == None:
        return None
        
    dir_path = os.path.dirname(self.script_file) + &#34;/&#34;
    return dir_path</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.log_line"><code class="name flex">
<span>def <span class="ident">log_line</span></span>(<span>self, log_line)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>log_line(str):</strong> line of text.</p>
<p>Adds a line of text to log message displayed after completion or error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_line(self, log_line):
    &#34;&#34;&#34;
    **log_line(str):** line of text.
             
    Adds a line of text to log message displayed after completion or error.
    &#34;&#34;&#34;
    self.log_msg = self.log_msg + log_line + &#34;\n&#34;</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.set_author"><code class="name flex">
<span>def <span class="ident">set_author</span></span>(<span>self, author)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>author(str):</strong> name of script creator.</p>
<p>Must be called in script method <em>init_script()</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_author(self, author):
    &#34;&#34;&#34;
    **author(str):** name of script creator.
    
    Must be called in script method *init_script()*.
    &#34;&#34;&#34;
    self.author = author</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.set_data_obj"><code class="name flex">
<span>def <span class="ident">set_data_obj</span></span>(<span>self, label, item)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>label(str):</strong> lable used to access data later using <em>get_data_obj(self, label)</em>.</p>
<p><strong>item(obj):</strong> data item being saved.</p>
<p>Saves data to be used later during execution of script. Using <strong>global</strong> would obivously be possible to replace this, but this is made available as a more clean solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_data_obj(self, label, item):
    &#34;&#34;&#34;
    **label(str):** lable used to access data later using *get_data_obj(self, label)*.

    **item(obj):** data item being saved.
    
    Saves data to be used later during execution of script. Using **global** would obivously be possible to replace this, but this is made available as a more clean solution.
    &#34;&#34;&#34;
    self.data[label] = item</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.set_editors_data"><code class="name flex">
<span>def <span class="ident">set_editors_data</span></span>(<span>self, editors_data_json)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>editors_data_json(str):</strong> string representation of JSON object.</p>
<p>Sets edited data to be used when rendering.</p>
<p>Input string must describe JSON object that can be turned into usable editor data.</p>
<p><em>Example with EDITOR_FLOAT and EDITOR_COLOR:</em></p>
<pre><code>[
    [&quot;Position X&quot;, 2, 1.0], 
    [&quot;BG Color&quot;, 4, [0.8, 0.2, 0.2, 1.0]]
]
</code></pre>
<p><em>General form:</em></p>
<pre><code>[
    [&lt;name&gt;, &lt;type&gt;, &lt;value&gt;], 
    ...
]
</code></pre>
<p>Using this method is not needed when creating <strong>Flowblade Media Plugins</strong>, application handles setting editors data.</p>
<p>Should be called in script method <em>init_render()</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_editors_data(self, editors_data_json):
    &#34;&#34;&#34;
    **editors_data_json(str):** string representation of JSON object.
             
    Sets edited data to be used when rendering.
    
    Input string must describe JSON object that can be turned into usable editor data.
    
    *Example with EDITOR_FLOAT and EDITOR_COLOR:*
    
    ```
    [
        [&#34;Position X&#34;, 2, 1.0], 
        [&#34;BG Color&#34;, 4, [0.8, 0.2, 0.2, 1.0]]
    ]
    ```
    
    *General form:*
    
    ```
    [
        [&lt;name&gt;, &lt;type&gt;, &lt;value&gt;], 
        ...
    ]
    ```
    
    Using this method is not needed when creating **Flowblade Media Plugins**, application handles setting editors data.
    
    Should be called in script method *init_render()*.
    &#34;&#34;&#34;
    new_editors_list = json.loads(editors_data_json)
    for editor in new_editors_list:
        name, type, value = editor
        self.editors[name] = (type, value)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.set_frame_name"><code class="name flex">
<span>def <span class="ident">set_frame_name</span></span>(<span>self, frame_name)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>frame_name(str):</strong> name used before number part in rendered frame files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frame_name(self, frame_name):
    &#34;&#34;&#34;        
    **frame_name(str):** name used before number part in rendered frame files.
    &#34;&#34;&#34;
    self.priv_context.frame_name = frame_name</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.set_length"><code class="name flex">
<span>def <span class="ident">set_length</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>length(int):</strong> New length of script in frames.</p>
<p>Sets length of script output in frames.</p>
<p>Must <em>not</em> be called in
<em>render_frames()</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_length(self, length):
    &#34;&#34;&#34;
    **length(int):** New length of script in frames.
    
    Sets length of script output in frames.
    
    Must *not* be called in  *render_frames()*.
    &#34;&#34;&#34;
    self.length = length</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>name(str):</strong> name of script displayed to user.</p>
<p>Must be called in script method <em>init_script()</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    &#34;&#34;&#34;
    **name(str):** name of script displayed to user.
    
    Must be called in script method *init_script()*.
    &#34;&#34;&#34;
    self.name = name
    self.priv_context.error_on_wrong_method(&#34;set_name()&#34;, METHOD_INIT_SCRIPT)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContext.set_version"><code class="name flex">
<span>def <span class="ident">set_version</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>version(int):</strong> version of script, use increasing integer numbering. Default value is <em>1</em>.</p>
<p>Must be called in script method <em>init_script()</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_version(self, version):
    &#34;&#34;&#34;
    **version(int):** version of script, use increasing integer numbering. Default value is *1*.
    
    Must be called in script method *init_script()*.
    &#34;&#34;&#34;
    self.version = version
    self.priv_context.error_on_wrong_method(&#34;set_version()&#34;, METHOD_INIT_SCRIPT)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fluxity.FluxityContextPrivate"><code class="flex name class">
<span>class <span class="ident">FluxityContextPrivate</span></span>
<span>(</span><span>output_folder)</span>
</code></dt>
<dd>
<div class="desc"><p>This class exists to keep FluxityContext API clean for script developers.</p>
<p>Internal class, do not use objects of this class directly in scripts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FluxityContextPrivate:
    &#34;&#34;&#34;
    This class exists to keep FluxityContext API clean for script developers.
    
    Internal class, do not use objects of this class directly in scripts. 
    &#34;&#34;&#34;
    def __init__(self, output_folder):

        self.profile = None
        
        self.output_folder = output_folder
        self.start_out_from_frame_one = False
        self.in_frame = -1

        self.frame = -1
        
        self.frame_surface = None
        self.frame_cr = None

        self.frame_name = &#34;frame&#34;
        self.first_rendered_frame_path = None # This is cleared by rendering routines.

        self.current_method = None
        self.method_name = {METHOD_INIT_SCRIPT:&#34;init_script()&#34;, METHOD_INIT_RENDER:&#34;init_render()&#34;, METHOD_RENDER_FRAME:&#34;render_frame()&#34;}
        
        self.repo = None
        
    def load_profile(self, mlt_profile_path):
        lines = []
        with open(mlt_profile_path, &#34;r&#34;) as f:
            for line in f:
                lines.append(line.strip())
        data = {}
        data[FluxityProfile.DESCRIPTION] = _read_profile_prop_from_lines(lines, FluxityProfile.DESCRIPTION)
        data[FluxityProfile.FRAME_RATE_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.FRAME_RATE_NUM)
        data[FluxityProfile.FRAME_RATE_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.FRAME_RATE_DEN)
        data[FluxityProfile.WIDTH] = int(_read_profile_prop_from_lines(lines, FluxityProfile.WIDTH))
        data[FluxityProfile.HEIGHT] = int(_read_profile_prop_from_lines(lines, FluxityProfile.HEIGHT))
        data[FluxityProfile.PROGRESSIVE] = _read_profile_prop_from_lines(lines, FluxityProfile.PROGRESSIVE)
        data[FluxityProfile.SAMPLE_ASPECT_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.SAMPLE_ASPECT_NUM)
        data[FluxityProfile.SAMPLE_ASPECT_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.SAMPLE_ASPECT_DEN)
        data[FluxityProfile.DISPLAY_ASPECT_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.DISPLAY_ASPECT_NUM)
        data[FluxityProfile.DISPLAY_ASPECT_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.DISPLAY_ASPECT_DEN)
        data[FluxityProfile.COLORSPACE] = _read_profile_prop_from_lines(lines, FluxityProfile.COLORSPACE)

        self.profile = FluxityProfile(data)

        return self.profile.profile_data
        
    def create_frame_surface(self, frame):
        self.frame = frame
        w = self.profile.profile_data[FluxityProfile.WIDTH]
        h = self.profile.profile_data[FluxityProfile.HEIGHT]
        self.frame_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, w, h)
        self.frame_cr = cairo.Context(self.frame_surface)

    def write_out_frame(self, is_preview_frame=False):
        if self.output_folder == None or os.path.isdir(self.output_folder) == False:
            exception_msg = &#34;Output folder &#34; + self.output_folder + &#34; does not exist.&#34;
            _raise_fluxity_error(exception_msg)
        
        out_frame_number = self.frame
        if self.start_out_from_frame_one == True:
            out_frame_number = self.frame - self.in_frame + 1 

        filepath = self.output_folder + &#34;/&#34; + self.frame_name + &#34;_&#34; + str(out_frame_number).rjust(5, &#34;0&#34;) + &#34;.png&#34;
        if is_preview_frame == True:
            filepath = self.output_folder + &#34;/preview.png&#34;
        self.frame_surface.write_to_png(filepath)

        if self.first_rendered_frame_path == None:
            self.first_rendered_frame_path = filepath

    def get_preview_frame_path(self):
        return self.output_folder + &#34;/preview.png&#34;
    
    def error_on_wrong_method(self, method_name, required_method):
        if required_method == self.current_method:
            return
        
        error_str = &#34;&#39;FluxityContext.&#34; + method_name + &#34;&#39; has to called in script method &#39;&#34; + self.method_name[required_method] + &#34;&#39;.&#34;
        _raise_contained_error(error_str)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fluxity.FluxityContextPrivate.create_frame_surface"><code class="name flex">
<span>def <span class="ident">create_frame_surface</span></span>(<span>self, frame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_frame_surface(self, frame):
    self.frame = frame
    w = self.profile.profile_data[FluxityProfile.WIDTH]
    h = self.profile.profile_data[FluxityProfile.HEIGHT]
    self.frame_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, w, h)
    self.frame_cr = cairo.Context(self.frame_surface)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContextPrivate.error_on_wrong_method"><code class="name flex">
<span>def <span class="ident">error_on_wrong_method</span></span>(<span>self, method_name, required_method)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_on_wrong_method(self, method_name, required_method):
    if required_method == self.current_method:
        return
    
    error_str = &#34;&#39;FluxityContext.&#34; + method_name + &#34;&#39; has to called in script method &#39;&#34; + self.method_name[required_method] + &#34;&#39;.&#34;
    _raise_contained_error(error_str)</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContextPrivate.get_preview_frame_path"><code class="name flex">
<span>def <span class="ident">get_preview_frame_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_preview_frame_path(self):
    return self.output_folder + &#34;/preview.png&#34;</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContextPrivate.load_profile"><code class="name flex">
<span>def <span class="ident">load_profile</span></span>(<span>self, mlt_profile_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_profile(self, mlt_profile_path):
    lines = []
    with open(mlt_profile_path, &#34;r&#34;) as f:
        for line in f:
            lines.append(line.strip())
    data = {}
    data[FluxityProfile.DESCRIPTION] = _read_profile_prop_from_lines(lines, FluxityProfile.DESCRIPTION)
    data[FluxityProfile.FRAME_RATE_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.FRAME_RATE_NUM)
    data[FluxityProfile.FRAME_RATE_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.FRAME_RATE_DEN)
    data[FluxityProfile.WIDTH] = int(_read_profile_prop_from_lines(lines, FluxityProfile.WIDTH))
    data[FluxityProfile.HEIGHT] = int(_read_profile_prop_from_lines(lines, FluxityProfile.HEIGHT))
    data[FluxityProfile.PROGRESSIVE] = _read_profile_prop_from_lines(lines, FluxityProfile.PROGRESSIVE)
    data[FluxityProfile.SAMPLE_ASPECT_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.SAMPLE_ASPECT_NUM)
    data[FluxityProfile.SAMPLE_ASPECT_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.SAMPLE_ASPECT_DEN)
    data[FluxityProfile.DISPLAY_ASPECT_NUM] = _read_profile_prop_from_lines(lines, FluxityProfile.DISPLAY_ASPECT_NUM)
    data[FluxityProfile.DISPLAY_ASPECT_DEN] = _read_profile_prop_from_lines(lines, FluxityProfile.DISPLAY_ASPECT_DEN)
    data[FluxityProfile.COLORSPACE] = _read_profile_prop_from_lines(lines, FluxityProfile.COLORSPACE)

    self.profile = FluxityProfile(data)

    return self.profile.profile_data</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityContextPrivate.write_out_frame"><code class="name flex">
<span>def <span class="ident">write_out_frame</span></span>(<span>self, is_preview_frame=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_out_frame(self, is_preview_frame=False):
    if self.output_folder == None or os.path.isdir(self.output_folder) == False:
        exception_msg = &#34;Output folder &#34; + self.output_folder + &#34; does not exist.&#34;
        _raise_fluxity_error(exception_msg)
    
    out_frame_number = self.frame
    if self.start_out_from_frame_one == True:
        out_frame_number = self.frame - self.in_frame + 1 

    filepath = self.output_folder + &#34;/&#34; + self.frame_name + &#34;_&#34; + str(out_frame_number).rjust(5, &#34;0&#34;) + &#34;.png&#34;
    if is_preview_frame == True:
        filepath = self.output_folder + &#34;/preview.png&#34;
    self.frame_surface.write_to_png(filepath)

    if self.first_rendered_frame_path == None:
        self.first_rendered_frame_path = filepath</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fluxity.FluxityEmptyClass"><code class="flex name class">
<span>class <span class="ident">FluxityEmptyClass</span></span>
</code></dt>
<dd>
<div class="desc"><p>Internal class, do not use objects of this class directly in scripts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FluxityEmptyClass:
    &#34;&#34;&#34;
    Internal class, do not use objects of this class directly in scripts.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityError"><code class="flex name class">
<span>class <span class="ident">FluxityError</span></span>
<span>(</span><span>msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Errors specific to using Fluxity API.</p>
<p>Internal class, do not use objects of this class directly in scripts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FluxityError(Exception):
    &#34;&#34;&#34;
    Errors specific to using Fluxity API.
    
    Internal class, do not use objects of this class directly in scripts. 
    &#34;&#34;&#34;
    def __init__(self, msg):
        self.message = msg
        super().__init__(self.message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="fluxity.FluxityProfile"><code class="flex name class">
<span>class <span class="ident">FluxityProfile</span></span>
<span>(</span><span>profile_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Properties of this class correspond MLT profile objects.</p>
<p>Internal class, do not use objects of this class directly in scripts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FluxityProfile:
    &#34;&#34;&#34;    
    Properties of this class correspond MLT profile objects.
    
    Internal class, do not use objects of this class directly in scripts. 
    &#34;&#34;&#34;
    DESCRIPTION = &#34;description&#34;
    FRAME_RATE_NUM = &#34;frame_rate_num&#34;
    FRAME_RATE_DEN = &#34;frame_rate_den&#34;
    WIDTH = &#34;width&#34;
    HEIGHT = &#34;height&#34;
    PROGRESSIVE = &#34;progressive&#34;
    SAMPLE_ASPECT_NUM = &#34;sample_aspect_num&#34;
    SAMPLE_ASPECT_DEN = &#34;sample_aspect_den&#34;
    DISPLAY_ASPECT_NUM = &#34;display_aspect_num&#34;
    DISPLAY_ASPECT_DEN = &#34;display_aspect_den&#34;
    COLORSPACE = &#34;colorspace&#34;
        
    def __init__(self, profile_data):
        self.profile_data = profile_data
    
    def get_profile_property(self, prop):
        return self.profile_data[prop]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="fluxity.FluxityProfile.COLORSPACE"><code class="name">var <span class="ident">COLORSPACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.DESCRIPTION"><code class="name">var <span class="ident">DESCRIPTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.DISPLAY_ASPECT_DEN"><code class="name">var <span class="ident">DISPLAY_ASPECT_DEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.DISPLAY_ASPECT_NUM"><code class="name">var <span class="ident">DISPLAY_ASPECT_NUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.FRAME_RATE_DEN"><code class="name">var <span class="ident">FRAME_RATE_DEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.FRAME_RATE_NUM"><code class="name">var <span class="ident">FRAME_RATE_NUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.HEIGHT"><code class="name">var <span class="ident">HEIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.PROGRESSIVE"><code class="name">var <span class="ident">PROGRESSIVE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.SAMPLE_ASPECT_DEN"><code class="name">var <span class="ident">SAMPLE_ASPECT_DEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.SAMPLE_ASPECT_NUM"><code class="name">var <span class="ident">SAMPLE_ASPECT_NUM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fluxity.FluxityProfile.WIDTH"><code class="name">var <span class="ident">WIDTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fluxity.FluxityProfile.get_profile_property"><code class="name flex">
<span>def <span class="ident">get_profile_property</span></span>(<span>self, prop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_profile_property(self, prop):
    return self.profile_data[prop]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fluxity.FluxityScript"><code class="flex name class">
<span>class <span class="ident">FluxityScript</span></span>
<span>(</span><span>script_str)</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles script to an executable object and calls methods <em>init_script()</em>, <em>init_render()</em>, <em>render_frame()</em> on it.</p>
<p>Internal class, do not use objects of this class directly in scripts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FluxityScript:
    &#34;&#34;&#34;
    Compiles script to an executable object and calls methods *init_script()*, *init_render()*, *render_frame()* on it.
    
    Internal class, do not use objects of this class directly in scripts.
    &#34;&#34;&#34;
    
    def __init__(self, script_str):
        self.script = script_str
        self.code = None
        self.namespace = {}
    
    def compile_script(self):
        &#34;&#34;&#34;
        Compiles user script.
        &#34;&#34;&#34;
        try:
            self.code = compile(self.script, &#34;&lt;fluxityscript&gt;&#34;, &#34;exec&#34;)
        except Exception as e:
            _raise_compile_error(str(e))
        
        code_names = sorted(self.code.co_names)
        required_names = sorted([&#34;init_script&#34;,&#34;init_render&#34;,&#34;render_frame&#34;])
        contains_all = all(elem in code_names for elem in required_names)
        if contains_all == False:
            _raise_fluxity_error(&#34;Functions names &#34; + str(required_names) + &#34; all required to be in script, you have: &#34; + str(code_names))
  
        try:
            exec(self.code, self.namespace)
        except Exception as e:
            _raise_exec_error(str(e))
    
    def call_init_script(self, fctx):
        &#34;&#34;&#34;
        Calls method *init_script()* on script.
        &#34;&#34;&#34;
        try:
          self.namespace[&#39;init_script&#39;](fctx)
        except Exception as e:
          _raise_fluxity_error(&#34;error calling function &#39;init_script()&#39;:&#34; + str(e))

    def call_init_render(self, fctx):
        &#34;&#34;&#34;
        Calls method *init_render()* on script.
        &#34;&#34;&#34;
        try:
          self.namespace[&#39;init_render&#39;](fctx)
        except Exception as e:
          _raise_fluxity_error(&#34;error calling function &#39;init_render()&#39;:\n\n&#34; + str(e))
          
    def call_render_frame(self, frame, fctx, w, h):
        &#34;&#34;&#34;
        Calls method *render_frame()* on script.
        &#34;&#34;&#34;
        try:
          self.namespace[&#39;render_frame&#39;](frame, fctx, w, h)
        except Exception as e:
          _raise_fluxity_error(&#34;error calling function &#39;render_frame()&#39;:\n\n&#34; + str(e))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fluxity.FluxityScript.call_init_render"><code class="name flex">
<span>def <span class="ident">call_init_render</span></span>(<span>self, fctx)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls method <em>init_render()</em> on script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_init_render(self, fctx):
    &#34;&#34;&#34;
    Calls method *init_render()* on script.
    &#34;&#34;&#34;
    try:
      self.namespace[&#39;init_render&#39;](fctx)
    except Exception as e:
      _raise_fluxity_error(&#34;error calling function &#39;init_render()&#39;:\n\n&#34; + str(e))</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityScript.call_init_script"><code class="name flex">
<span>def <span class="ident">call_init_script</span></span>(<span>self, fctx)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls method <em>init_script()</em> on script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_init_script(self, fctx):
    &#34;&#34;&#34;
    Calls method *init_script()* on script.
    &#34;&#34;&#34;
    try:
      self.namespace[&#39;init_script&#39;](fctx)
    except Exception as e:
      _raise_fluxity_error(&#34;error calling function &#39;init_script()&#39;:&#34; + str(e))</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityScript.call_render_frame"><code class="name flex">
<span>def <span class="ident">call_render_frame</span></span>(<span>self, frame, fctx, w, h)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls method <em>render_frame()</em> on script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_render_frame(self, frame, fctx, w, h):
    &#34;&#34;&#34;
    Calls method *render_frame()* on script.
    &#34;&#34;&#34;
    try:
      self.namespace[&#39;render_frame&#39;](frame, fctx, w, h)
    except Exception as e:
      _raise_fluxity_error(&#34;error calling function &#39;render_frame()&#39;:\n\n&#34; + str(e))</code></pre>
</details>
</dd>
<dt id="fluxity.FluxityScript.compile_script"><code class="name flex">
<span>def <span class="ident">compile_script</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles user script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_script(self):
    &#34;&#34;&#34;
    Compiles user script.
    &#34;&#34;&#34;
    try:
        self.code = compile(self.script, &#34;&lt;fluxityscript&gt;&#34;, &#34;exec&#34;)
    except Exception as e:
        _raise_compile_error(str(e))
    
    code_names = sorted(self.code.co_names)
    required_names = sorted([&#34;init_script&#34;,&#34;init_render&#34;,&#34;render_frame&#34;])
    contains_all = all(elem in code_names for elem in required_names)
    if contains_all == False:
        _raise_fluxity_error(&#34;Functions names &#34; + str(required_names) + &#34; all required to be in script, you have: &#34; + str(code_names))

    try:
        exec(self.code, self.namespace)
    except Exception as e:
        _raise_exec_error(str(e))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fluxity.PangoTextLayout"><code class="flex name class">
<span>class <span class="ident">PangoTextLayout</span></span>
<span>(</span><span>font_data)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>font_data(tuple)</strong> this tuple can be aquired by calling <em>FluxityContext.get_editor_value()</em> on editors of type <em>FluxityContext.EDITOR_PANGO_FONT</em>.</p>
<p>Object for drawing text. Uses internally Pango.</p>
<p>Instances of this object can be created using <em>FluxityContext.create_text_layout(font_data)</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PangoTextLayout:

    &#34;&#34;&#34;
    **font_data(tuple)** this tuple can be aquired by calling *FluxityContext.get_editor_value()* on editors of type *FluxityContext.EDITOR_PANGO_FONT*.
            
    Object for drawing text. Uses internally Pango.
    
    Instances of this object can be created using *FluxityContext.create_text_layout(font_data)*.
    &#34;&#34;&#34;
    def __init__(self, font_data):
        self.font_family, self.font_face, self.font_size, self.alignment, \
        self.color_rgba, self.fill_on, self.outline_color_rgba, self.outline_on, \
        self.outline_width, self.shadow_on, self.shadow_color_rgb, self.shadow_opacity, \
        self.shadow_xoff, self.shadow_yoff, self.shadow_blur, self.gradient_color_rgba, \
        self.gradient_direction = font_data
        self.font_desc = Pango.FontDescription(self.font_family + &#34; &#34; + self.font_face + &#34; &#34; + str(self.font_size))
        self.pango_layout = None

    def create_pango_layout(self, cr, text):
        &#34;&#34;&#34;
        **cr(cairo.Context)** frame cairo context aquired with FluxityContext.get_frame_cr().
        
        **text(str)** displayed text.
        
        Creates internally PangoCairo layout object. Calling this is required before calling *get_pixel_size()*.
        &#34;&#34;&#34;
        self.text = text
        self.pango_layout = PangoCairo.create_layout(cr)
        self.pango_layout.set_text(self.text, -1)
        self.pango_layout.set_font_description(self.font_desc)
        self.pango_layout.set_alignment(self.alignment)
        self.pixel_size = self.pango_layout.get_pixel_size()
        
    # called from vieweditor draw vieweditor-&gt; editorlayer-&gt;here
    def draw_layout(self, text, cr, x, y, rotation=0.0, xscale=1.0, yscale=1.0):
        &#34;&#34;&#34;
        **text(str)** displayed text.
        
        **cr(cairo.Context)** frame cairo context aquired with *FluxityContext.get_frame_cr()*.
        
        **x(float)** Text X position.

        **y(float)** Text Y position.

        **rotation(float)** Text rotation.

        **xscale(float)** Text X scaling.

        **yscale(float)** Text Y scaling.

        Draws text on provided *cairo.Context*.
        
        Calls internally *create_pango_layout()* so *get_pixel_size()* can be called after this.
        &#34;&#34;&#34;
        self.text = text
        cr.save() # Created each frame
        
        self.create_pango_layout(cr, text)
        layout = self.pango_layout # this just artifact of dev. history, create_pango_layout() was added later then draw_layout()
                                   # to be used in typewriter plugin.
        # Shadow
        if self.shadow_on:
            cr.save()

            # Get colors.
            r, g, b = self.shadow_color_rgb
            a = self.shadow_opacity / 100.0

            # Blurred shadow need its own ImageSurface
            if self.shadow_blur != 0.0:
                blurred_img = cairo.ImageSurface(cairo.FORMAT_ARGB32, view_editor.profile_w,  view_editor.profile_h)
                cr_blurred = cairo.Context(blurred_img)
                transform_cr = cr_blurred # Set draw transform_cr to context for newly created image.
            else:
                transform_cr = cr # Set draw transform_cr to out context.

            # Transform and set color.
            transform_cr.set_source_rgba(r, g, b, a)
            effective_shadow_xoff = self.shadow_xoff * xscale
            effective_shadow_yoff = self.shadow_yoff * yscale
            transform_cr.move_to(x + effective_shadow_xoff, y + effective_shadow_yoff)
            transform_cr.scale(xscale, yscale)
            transform_cr.rotate(rotation)

            # If no blur for shadow, just draw layout on out context.
            if self.shadow_blur == 0.0:
                PangoCairo.update_layout(cr, layout)
                PangoCairo.show_layout(cr, layout)
                cr.restore()
            else:
                # If we have blur - draw shadow, blur it and then draw on out context.
                PangoCairo.update_layout(cr_blurred, layout)
                PangoCairo.show_layout(cr_blurred, layout)

                img2 = Image.frombuffer(&#34;RGBA&#34;, (blurred_img.get_width(), blurred_img.get_height()), blurred_img.get_data(), &#34;raw&#34;, &#34;RGBA&#34;, 0, 1)
                effective_blur = xscale * self.shadow_blur # This is not going to be exact
                                                           # on non-100% scales but let&#39;s try to get approximation. 
                img2 = img2.filter(ImageFilter.GaussianBlur(radius=int(effective_blur)))
                imgd = img2.tobytes()
                a = array.array(&#39;B&#39;,imgd)

                stride = blurred_img.get_width() * 4
                draw_surface = cairo.ImageSurface.create_for_data (a, cairo.FORMAT_ARGB32,
                                                              blurred_img.get_width(), blurred_img.get_height(), stride)
                cr.restore()
                cr.set_source_surface(draw_surface, 0, 0)
                cr.paint()

        # Text
        if self.fill_on:
            if self.gradient_color_rgba == None:
                cr.set_source_rgba(*self.color_rgba)
            else:
                w, h = self.pixel_size
                w = float(w) * xscale
                h = float(h) * yscale
                if self.gradient_direction == HORIZONTAL:
                    grad = cairo.LinearGradient (x, 0, x + w, 0)
                else:
                    grad = cairo.LinearGradient (0, y, 0, y + h)
                
                r, g, b, a = self.color_rgba
                rg, gg, bg, ag =  self.gradient_color_rgba 
                    
                CLIP_COLOR_GRAD_1 = (0,  r, g, b, 1)
                CLIP_COLOR_GRAD_2 = (1,  rg, gg, bg, 1)
                grad.add_color_stop_rgba(*CLIP_COLOR_GRAD_1)
                grad.add_color_stop_rgba(*CLIP_COLOR_GRAD_2)
                cr.set_source(grad)

            cr.move_to(x, y)
            cr.scale(xscale, yscale)
            cr.rotate(rotation)
            
            PangoCairo.update_layout(cr, layout)
            PangoCairo.show_layout(cr, layout)
        
        # Outline
        if self.outline_on:
            if self.fill_on == False: # case when user only wants outline we need to transform here
                cr.move_to(x, y)
                cr.scale(xscale, yscale)
                cr.rotate(rotation)
            PangoCairo.layout_path(cr, layout)
            cr.set_source_rgba(*self.outline_color_rgba)
            cr.set_line_width(self.outline_width)
            cr.stroke()
        
        cr.restore()

    def get_pixel_size(self):
        &#34;&#34;&#34;             
        Returns size of layout.

        Before calling this PangoCairo layout object needs to creted *create_pango_layout()* or *draw_layout().*
        
        **Returns:** (width, height) pixel size of layout.
        &#34;&#34;&#34;
        return self.pixel_size 

    def get_pango_alignment(self):
        &#34;&#34;&#34;             
        Returns alignment for his layout.

        To interpret enums script must do import *from gi.repository import Pango*
        
        **Returns:** (int) alignment enum, either *Pango.Alignment.CENTER*, *Pango.Alignment.LEFT* or *Pango.Alignment.RIGHT*.
        &#34;&#34;&#34;
        return self.alignment</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fluxity.PangoTextLayout.create_pango_layout"><code class="name flex">
<span>def <span class="ident">create_pango_layout</span></span>(<span>self, cr, text)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>cr(cairo.Context)</strong> frame cairo context aquired with FluxityContext.get_frame_cr().</p>
<p><strong>text(str)</strong> displayed text.</p>
<p>Creates internally PangoCairo layout object. Calling this is required before calling <em>get_pixel_size()</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_pango_layout(self, cr, text):
    &#34;&#34;&#34;
    **cr(cairo.Context)** frame cairo context aquired with FluxityContext.get_frame_cr().
    
    **text(str)** displayed text.
    
    Creates internally PangoCairo layout object. Calling this is required before calling *get_pixel_size()*.
    &#34;&#34;&#34;
    self.text = text
    self.pango_layout = PangoCairo.create_layout(cr)
    self.pango_layout.set_text(self.text, -1)
    self.pango_layout.set_font_description(self.font_desc)
    self.pango_layout.set_alignment(self.alignment)
    self.pixel_size = self.pango_layout.get_pixel_size()</code></pre>
</details>
</dd>
<dt id="fluxity.PangoTextLayout.draw_layout"><code class="name flex">
<span>def <span class="ident">draw_layout</span></span>(<span>self, text, cr, x, y, rotation=0.0, xscale=1.0, yscale=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>text(str)</strong> displayed text.</p>
<p><strong>cr(cairo.Context)</strong> frame cairo context aquired with <em>FluxityContext.get_frame_cr()</em>.</p>
<p><strong>x(float)</strong> Text X position.</p>
<p><strong>y(float)</strong> Text Y position.</p>
<p><strong>rotation(float)</strong> Text rotation.</p>
<p><strong>xscale(float)</strong> Text X scaling.</p>
<p><strong>yscale(float)</strong> Text Y scaling.</p>
<p>Draws text on provided <em>cairo.Context</em>.</p>
<p>Calls internally <em>create_pango_layout()</em> so <em>get_pixel_size()</em> can be called after this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_layout(self, text, cr, x, y, rotation=0.0, xscale=1.0, yscale=1.0):
    &#34;&#34;&#34;
    **text(str)** displayed text.
    
    **cr(cairo.Context)** frame cairo context aquired with *FluxityContext.get_frame_cr()*.
    
    **x(float)** Text X position.

    **y(float)** Text Y position.

    **rotation(float)** Text rotation.

    **xscale(float)** Text X scaling.

    **yscale(float)** Text Y scaling.

    Draws text on provided *cairo.Context*.
    
    Calls internally *create_pango_layout()* so *get_pixel_size()* can be called after this.
    &#34;&#34;&#34;
    self.text = text
    cr.save() # Created each frame
    
    self.create_pango_layout(cr, text)
    layout = self.pango_layout # this just artifact of dev. history, create_pango_layout() was added later then draw_layout()
                               # to be used in typewriter plugin.
    # Shadow
    if self.shadow_on:
        cr.save()

        # Get colors.
        r, g, b = self.shadow_color_rgb
        a = self.shadow_opacity / 100.0

        # Blurred shadow need its own ImageSurface
        if self.shadow_blur != 0.0:
            blurred_img = cairo.ImageSurface(cairo.FORMAT_ARGB32, view_editor.profile_w,  view_editor.profile_h)
            cr_blurred = cairo.Context(blurred_img)
            transform_cr = cr_blurred # Set draw transform_cr to context for newly created image.
        else:
            transform_cr = cr # Set draw transform_cr to out context.

        # Transform and set color.
        transform_cr.set_source_rgba(r, g, b, a)
        effective_shadow_xoff = self.shadow_xoff * xscale
        effective_shadow_yoff = self.shadow_yoff * yscale
        transform_cr.move_to(x + effective_shadow_xoff, y + effective_shadow_yoff)
        transform_cr.scale(xscale, yscale)
        transform_cr.rotate(rotation)

        # If no blur for shadow, just draw layout on out context.
        if self.shadow_blur == 0.0:
            PangoCairo.update_layout(cr, layout)
            PangoCairo.show_layout(cr, layout)
            cr.restore()
        else:
            # If we have blur - draw shadow, blur it and then draw on out context.
            PangoCairo.update_layout(cr_blurred, layout)
            PangoCairo.show_layout(cr_blurred, layout)

            img2 = Image.frombuffer(&#34;RGBA&#34;, (blurred_img.get_width(), blurred_img.get_height()), blurred_img.get_data(), &#34;raw&#34;, &#34;RGBA&#34;, 0, 1)
            effective_blur = xscale * self.shadow_blur # This is not going to be exact
                                                       # on non-100% scales but let&#39;s try to get approximation. 
            img2 = img2.filter(ImageFilter.GaussianBlur(radius=int(effective_blur)))
            imgd = img2.tobytes()
            a = array.array(&#39;B&#39;,imgd)

            stride = blurred_img.get_width() * 4
            draw_surface = cairo.ImageSurface.create_for_data (a, cairo.FORMAT_ARGB32,
                                                          blurred_img.get_width(), blurred_img.get_height(), stride)
            cr.restore()
            cr.set_source_surface(draw_surface, 0, 0)
            cr.paint()

    # Text
    if self.fill_on:
        if self.gradient_color_rgba == None:
            cr.set_source_rgba(*self.color_rgba)
        else:
            w, h = self.pixel_size
            w = float(w) * xscale
            h = float(h) * yscale
            if self.gradient_direction == HORIZONTAL:
                grad = cairo.LinearGradient (x, 0, x + w, 0)
            else:
                grad = cairo.LinearGradient (0, y, 0, y + h)
            
            r, g, b, a = self.color_rgba
            rg, gg, bg, ag =  self.gradient_color_rgba 
                
            CLIP_COLOR_GRAD_1 = (0,  r, g, b, 1)
            CLIP_COLOR_GRAD_2 = (1,  rg, gg, bg, 1)
            grad.add_color_stop_rgba(*CLIP_COLOR_GRAD_1)
            grad.add_color_stop_rgba(*CLIP_COLOR_GRAD_2)
            cr.set_source(grad)

        cr.move_to(x, y)
        cr.scale(xscale, yscale)
        cr.rotate(rotation)
        
        PangoCairo.update_layout(cr, layout)
        PangoCairo.show_layout(cr, layout)
    
    # Outline
    if self.outline_on:
        if self.fill_on == False: # case when user only wants outline we need to transform here
            cr.move_to(x, y)
            cr.scale(xscale, yscale)
            cr.rotate(rotation)
        PangoCairo.layout_path(cr, layout)
        cr.set_source_rgba(*self.outline_color_rgba)
        cr.set_line_width(self.outline_width)
        cr.stroke()
    
    cr.restore()</code></pre>
</details>
</dd>
<dt id="fluxity.PangoTextLayout.get_pango_alignment"><code class="name flex">
<span>def <span class="ident">get_pango_alignment</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns alignment for his layout.</p>
<p>To interpret enums script must do import <em>from gi.repository import Pango</em></p>
<p><strong>Returns:</strong> (int) alignment enum, either <em>Pango.Alignment.CENTER</em>, <em>Pango.Alignment.LEFT</em> or <em>Pango.Alignment.RIGHT</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pango_alignment(self):
    &#34;&#34;&#34;             
    Returns alignment for his layout.

    To interpret enums script must do import *from gi.repository import Pango*
    
    **Returns:** (int) alignment enum, either *Pango.Alignment.CENTER*, *Pango.Alignment.LEFT* or *Pango.Alignment.RIGHT*.
    &#34;&#34;&#34;
    return self.alignment</code></pre>
</details>
</dd>
<dt id="fluxity.PangoTextLayout.get_pixel_size"><code class="name flex">
<span>def <span class="ident">get_pixel_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns size of layout.</p>
<p>Before calling this PangoCairo layout object needs to creted <em>create_pango_layout()</em> or <em>draw_layout().</em></p>
<p><strong>Returns:</strong> (width, height) pixel size of layout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixel_size(self):
    &#34;&#34;&#34;             
    Returns size of layout.

    Before calling this PangoCairo layout object needs to creted *create_pango_layout()* or *draw_layout().*
    
    **Returns:** (width, height) pixel size of layout.
    &#34;&#34;&#34;
    return self.pixel_size </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#gpl-licence-text">GPL Licence text</a></li>
<li><a href="#fluxity-scripting">FLUXITY SCRIPTING</a><ul>
<li><a href="#required-interface">REQUIRED INTERFACE</a></li>
<li><a href="#flowblade-media-plugin-api">FLOWBLADE MEDIA PLUGIN API</a></li>
<li><a href="#flowblade-media-plugin-script-lifecycle">FLOWBLADE MEDIA PLUGIN SCRIPT LIFECYCLE</a></li>
<li><a href="#example-script">EXAMPLE SCRIPT</a><ul>
<li><a href="#init_script">init_script()</a></li>
<li><a href="#init_render">init_render()</a></li>
<li><a href="#render_frame">render_frame()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fluxity.render_frame_sequence" href="#fluxity.render_frame_sequence">render_frame_sequence</a></code></li>
<li><code><a title="fluxity.render_preview_frame" href="#fluxity.render_preview_frame">render_preview_frame</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fluxity.FluxityContext" href="#fluxity.FluxityContext">FluxityContext</a></code></h4>
<ul class="">
<li><code><a title="fluxity.FluxityContext.EDITOR_CHECK_BOX" href="#fluxity.FluxityContext.EDITOR_CHECK_BOX">EDITOR_CHECK_BOX</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_COLOR" href="#fluxity.FluxityContext.EDITOR_COLOR">EDITOR_COLOR</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_FILE_PATH" href="#fluxity.FluxityContext.EDITOR_FILE_PATH">EDITOR_FILE_PATH</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_FLOAT" href="#fluxity.FluxityContext.EDITOR_FLOAT">EDITOR_FLOAT</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_FLOAT_RANGE" href="#fluxity.FluxityContext.EDITOR_FLOAT_RANGE">EDITOR_FLOAT_RANGE</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_INT" href="#fluxity.FluxityContext.EDITOR_INT">EDITOR_INT</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_INT_RANGE" href="#fluxity.FluxityContext.EDITOR_INT_RANGE">EDITOR_INT_RANGE</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_OPTIONS" href="#fluxity.FluxityContext.EDITOR_OPTIONS">EDITOR_OPTIONS</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_PANGO_FONT" href="#fluxity.FluxityContext.EDITOR_PANGO_FONT">EDITOR_PANGO_FONT</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_PANGO_FONT_DEFAULT_VALUES" href="#fluxity.FluxityContext.EDITOR_PANGO_FONT_DEFAULT_VALUES">EDITOR_PANGO_FONT_DEFAULT_VALUES</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_STRING" href="#fluxity.FluxityContext.EDITOR_STRING">EDITOR_STRING</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_TEXT" href="#fluxity.FluxityContext.EDITOR_TEXT">EDITOR_TEXT</a></code></li>
<li><code><a title="fluxity.FluxityContext.EDITOR_TEXT_AREA" href="#fluxity.FluxityContext.EDITOR_TEXT_AREA">EDITOR_TEXT_AREA</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_COLORSPACE" href="#fluxity.FluxityContext.PROFILE_COLORSPACE">PROFILE_COLORSPACE</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_DESCRIPTION" href="#fluxity.FluxityContext.PROFILE_DESCRIPTION">PROFILE_DESCRIPTION</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_DISPLAY_ASPECT_DEN" href="#fluxity.FluxityContext.PROFILE_DISPLAY_ASPECT_DEN">PROFILE_DISPLAY_ASPECT_DEN</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_DISPLAY_ASPECT_NUM" href="#fluxity.FluxityContext.PROFILE_DISPLAY_ASPECT_NUM">PROFILE_DISPLAY_ASPECT_NUM</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_FRAME_RATE_DEN" href="#fluxity.FluxityContext.PROFILE_FRAME_RATE_DEN">PROFILE_FRAME_RATE_DEN</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_FRAME_RATE_NUM" href="#fluxity.FluxityContext.PROFILE_FRAME_RATE_NUM">PROFILE_FRAME_RATE_NUM</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_HEIGHT" href="#fluxity.FluxityContext.PROFILE_HEIGHT">PROFILE_HEIGHT</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_PROGRESSIVE" href="#fluxity.FluxityContext.PROFILE_PROGRESSIVE">PROFILE_PROGRESSIVE</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_SAMPLE_ASPECT_DEN" href="#fluxity.FluxityContext.PROFILE_SAMPLE_ASPECT_DEN">PROFILE_SAMPLE_ASPECT_DEN</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_SAMPLE_ASPECT_NUM" href="#fluxity.FluxityContext.PROFILE_SAMPLE_ASPECT_NUM">PROFILE_SAMPLE_ASPECT_NUM</a></code></li>
<li><code><a title="fluxity.FluxityContext.PROFILE_WIDTH" href="#fluxity.FluxityContext.PROFILE_WIDTH">PROFILE_WIDTH</a></code></li>
<li><code><a title="fluxity.FluxityContext.add_editor" href="#fluxity.FluxityContext.add_editor">add_editor</a></code></li>
<li><code><a title="fluxity.FluxityContext.create_text_layout" href="#fluxity.FluxityContext.create_text_layout">create_text_layout</a></code></li>
<li><code><a title="fluxity.FluxityContext.get_data_obj" href="#fluxity.FluxityContext.get_data_obj">get_data_obj</a></code></li>
<li><code><a title="fluxity.FluxityContext.get_dimensions" href="#fluxity.FluxityContext.get_dimensions">get_dimensions</a></code></li>
<li><code><a title="fluxity.FluxityContext.get_editor_value" href="#fluxity.FluxityContext.get_editor_value">get_editor_value</a></code></li>
<li><code><a title="fluxity.FluxityContext.get_frame_cr" href="#fluxity.FluxityContext.get_frame_cr">get_frame_cr</a></code></li>
<li><code><a title="fluxity.FluxityContext.get_length" href="#fluxity.FluxityContext.get_length">get_length</a></code></li>
<li><code><a title="fluxity.FluxityContext.get_profile_property" href="#fluxity.FluxityContext.get_profile_property">get_profile_property</a></code></li>
<li><code><a title="fluxity.FluxityContext.get_script_data" href="#fluxity.FluxityContext.get_script_data">get_script_data</a></code></li>
<li><code><a title="fluxity.FluxityContext.get_script_dir" href="#fluxity.FluxityContext.get_script_dir">get_script_dir</a></code></li>
<li><code><a title="fluxity.FluxityContext.log_line" href="#fluxity.FluxityContext.log_line">log_line</a></code></li>
<li><code><a title="fluxity.FluxityContext.set_author" href="#fluxity.FluxityContext.set_author">set_author</a></code></li>
<li><code><a title="fluxity.FluxityContext.set_data_obj" href="#fluxity.FluxityContext.set_data_obj">set_data_obj</a></code></li>
<li><code><a title="fluxity.FluxityContext.set_editors_data" href="#fluxity.FluxityContext.set_editors_data">set_editors_data</a></code></li>
<li><code><a title="fluxity.FluxityContext.set_frame_name" href="#fluxity.FluxityContext.set_frame_name">set_frame_name</a></code></li>
<li><code><a title="fluxity.FluxityContext.set_length" href="#fluxity.FluxityContext.set_length">set_length</a></code></li>
<li><code><a title="fluxity.FluxityContext.set_name" href="#fluxity.FluxityContext.set_name">set_name</a></code></li>
<li><code><a title="fluxity.FluxityContext.set_version" href="#fluxity.FluxityContext.set_version">set_version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fluxity.FluxityContextPrivate" href="#fluxity.FluxityContextPrivate">FluxityContextPrivate</a></code></h4>
<ul class="">
<li><code><a title="fluxity.FluxityContextPrivate.create_frame_surface" href="#fluxity.FluxityContextPrivate.create_frame_surface">create_frame_surface</a></code></li>
<li><code><a title="fluxity.FluxityContextPrivate.error_on_wrong_method" href="#fluxity.FluxityContextPrivate.error_on_wrong_method">error_on_wrong_method</a></code></li>
<li><code><a title="fluxity.FluxityContextPrivate.get_preview_frame_path" href="#fluxity.FluxityContextPrivate.get_preview_frame_path">get_preview_frame_path</a></code></li>
<li><code><a title="fluxity.FluxityContextPrivate.load_profile" href="#fluxity.FluxityContextPrivate.load_profile">load_profile</a></code></li>
<li><code><a title="fluxity.FluxityContextPrivate.write_out_frame" href="#fluxity.FluxityContextPrivate.write_out_frame">write_out_frame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fluxity.FluxityEmptyClass" href="#fluxity.FluxityEmptyClass">FluxityEmptyClass</a></code></h4>
</li>
<li>
<h4><code><a title="fluxity.FluxityError" href="#fluxity.FluxityError">FluxityError</a></code></h4>
</li>
<li>
<h4><code><a title="fluxity.FluxityProfile" href="#fluxity.FluxityProfile">FluxityProfile</a></code></h4>
<ul class="">
<li><code><a title="fluxity.FluxityProfile.COLORSPACE" href="#fluxity.FluxityProfile.COLORSPACE">COLORSPACE</a></code></li>
<li><code><a title="fluxity.FluxityProfile.DESCRIPTION" href="#fluxity.FluxityProfile.DESCRIPTION">DESCRIPTION</a></code></li>
<li><code><a title="fluxity.FluxityProfile.DISPLAY_ASPECT_DEN" href="#fluxity.FluxityProfile.DISPLAY_ASPECT_DEN">DISPLAY_ASPECT_DEN</a></code></li>
<li><code><a title="fluxity.FluxityProfile.DISPLAY_ASPECT_NUM" href="#fluxity.FluxityProfile.DISPLAY_ASPECT_NUM">DISPLAY_ASPECT_NUM</a></code></li>
<li><code><a title="fluxity.FluxityProfile.FRAME_RATE_DEN" href="#fluxity.FluxityProfile.FRAME_RATE_DEN">FRAME_RATE_DEN</a></code></li>
<li><code><a title="fluxity.FluxityProfile.FRAME_RATE_NUM" href="#fluxity.FluxityProfile.FRAME_RATE_NUM">FRAME_RATE_NUM</a></code></li>
<li><code><a title="fluxity.FluxityProfile.HEIGHT" href="#fluxity.FluxityProfile.HEIGHT">HEIGHT</a></code></li>
<li><code><a title="fluxity.FluxityProfile.PROGRESSIVE" href="#fluxity.FluxityProfile.PROGRESSIVE">PROGRESSIVE</a></code></li>
<li><code><a title="fluxity.FluxityProfile.SAMPLE_ASPECT_DEN" href="#fluxity.FluxityProfile.SAMPLE_ASPECT_DEN">SAMPLE_ASPECT_DEN</a></code></li>
<li><code><a title="fluxity.FluxityProfile.SAMPLE_ASPECT_NUM" href="#fluxity.FluxityProfile.SAMPLE_ASPECT_NUM">SAMPLE_ASPECT_NUM</a></code></li>
<li><code><a title="fluxity.FluxityProfile.WIDTH" href="#fluxity.FluxityProfile.WIDTH">WIDTH</a></code></li>
<li><code><a title="fluxity.FluxityProfile.get_profile_property" href="#fluxity.FluxityProfile.get_profile_property">get_profile_property</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fluxity.FluxityScript" href="#fluxity.FluxityScript">FluxityScript</a></code></h4>
<ul class="">
<li><code><a title="fluxity.FluxityScript.call_init_render" href="#fluxity.FluxityScript.call_init_render">call_init_render</a></code></li>
<li><code><a title="fluxity.FluxityScript.call_init_script" href="#fluxity.FluxityScript.call_init_script">call_init_script</a></code></li>
<li><code><a title="fluxity.FluxityScript.call_render_frame" href="#fluxity.FluxityScript.call_render_frame">call_render_frame</a></code></li>
<li><code><a title="fluxity.FluxityScript.compile_script" href="#fluxity.FluxityScript.compile_script">compile_script</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fluxity.PangoTextLayout" href="#fluxity.PangoTextLayout">PangoTextLayout</a></code></h4>
<ul class="">
<li><code><a title="fluxity.PangoTextLayout.create_pango_layout" href="#fluxity.PangoTextLayout.create_pango_layout">create_pango_layout</a></code></li>
<li><code><a title="fluxity.PangoTextLayout.draw_layout" href="#fluxity.PangoTextLayout.draw_layout">draw_layout</a></code></li>
<li><code><a title="fluxity.PangoTextLayout.get_pango_alignment" href="#fluxity.PangoTextLayout.get_pango_alignment">get_pango_alignment</a></code></li>
<li><code><a title="fluxity.PangoTextLayout.get_pixel_size" href="#fluxity.PangoTextLayout.get_pixel_size">get_pixel_size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>